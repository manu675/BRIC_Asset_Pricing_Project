---
title: "BRIC_project"
author: 
  name: Manuel Schreiber
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
    df_print: paged
  html_notebook: default
  latex_engine: pdflatex
  pdf_document: default
  header-includes:
   - \usepackage{amsmath}
   - \usepackage{amsfonts}
---

**BRIC Project**

```{r}
# clear workspace
##rm(list=ls())
```


getting the current WD

```{r}
getwd()
```

changing the WD

```{r}
##setwd("/Users/Manu/Desktop/TUM_Master_Mgt_Technology/TUM_SS_21/Empirical Asset Pricing seminar/Seminar Thesis/BRIC_data")
```
# 0000. Reusable Code
```{r}
##summary(country_mcap$mc_sum[country_mcap$country.x == "BRA"])
##summary(country_mcap$mc_sum[country_mcap$country.x == "RUS"])
##summary(country_mcap$mc_sum[country_mcap$country.x == "IND"])
##summary(country_mcap$mc_sum[country_mcap$country.x == "CHN"])
# finding the number of NA values by column in the dataframe
##BRIC.monthly %>% mutate_all(is.na) %>% summarize_all(sum)


# idea:
# 
# big_stocks <- mcap_country %>%
#   select(ISIN) %>%
#  sort(mcap_country$WC07210, decreasing=T)  %>%
#   filter(mcap_country$WC07210 <= 0.9*country_mcap$mc_sum)
# 
# big_stocks
# 
# # sorting the stocks by market cap and extracting the ISINs of the biggest ones that make up 90% of a country's market cap
# 
# # RUSSIA
# # 90% of the market cap in Russia: 
# 0.9*country_mcap$mc_sum[4]
# 
# # subsetting all Russian stocks
# russian_stocks <- as.data.frame(mcap_country) %>%
#    filter(country.x == "RUS") 
# 
# # sorting the dataframe of russian stocks by decreasing market cap
# russian_stocks <- russian_stocks[order(russian_stocks$WC07210,decreasing = TRUE),]
#  
# # filtering out the big stocks which sum up to 90% of the market cap of Russian stocks
# big_stocks_RUS <- russian_stocks[cumsum(russian_stocks$WC07210) <= 0.9*country_mcap$mc_sum[4],]
# 
# big_stocks_RUS



#calculations done above!!!!





# https://alphaarchitect.com/2019/07/11/momentum-quality-and-r-code/

### TO DO: filter out the highest sharpe ratio Value stocks and take the top 25% instead of the median

## Momentum factor (based on Jagadeesh & Titman 1993, p.68)

# Specifically, a strategy that selects stocks on the basis of returns over
# the past J months and holds them for K months (we will refer to this as a
# J-month/K-month strategy) is constructed as follows: At the beginning of
# each month t the securities are ranked in ascending order on the basis of
# their returns in the past J months.

# creating a 12 months of past winners
# ret_tbl <- subset(BRIC.strategy, select= c("RET.USD","Id","ym"))
# # creating the 1st lag by id 
# lag_1id <- shift(BRIC.strategy$RET.USD,n=1)
# # creating the 12th lag by id 
# lag_12id <- shift(BRIC.strategy$RET.USD,n=12)
# 
# ret_tbl$mon_return <-  BRIC.strategy$RET.USD
# ret_tbl$skip_mon_return <- lag_1id
# ret_tbl$twelve_mon_return <- lag_12id
# 
# ---------------------------------
#   
# ret_tbl <- subset(BRIC.strategy, select= c("Id","ym","RET.USD"))
# 
# # creating the 1st lag by id 
# ret_tbl[, lag_1_vol := lag(RET.USD,1), by =Id]
# 
# # creating the 12th lag by id 
# ret_tbl[, lag_12_vol := lag(RET.USD,12), by =Id]
# 
# colnames(ret_tbl)[3] <- "mon_return"
# colnames(ret_tbl)[4] <- "skip_mon_return"
# colnames(ret_tbl)[5] <- "twelve_mon_return"
# 
# head(ret_tbl)
# 
# class(ret_tbl$mon_return)
# summary(ret_tbl)

--------------------------------------

# We want to add a layer of logic that says, count the number of positive months over the 
# preceding 12 months, and if equal to at least 8, encode a 1, else encode a 0

# First, we label each month as positive or negative. If positive, label it 1, if negative label it 0. That will allow us to sum the positive months.

# ret_tbl %>% 
#   slice(-1:-2) %>% 
#   mutate(pos_neg = case_when(skip_mon_return < 0 ~ 0,
#                              TRUE ~ 1))                    
# 
# # Next, we find the rolling sum of the pos_neg column
# ret_tbl %>% 
#   slice(-1:-2) %>% 
#   mutate(pos_neg = case_when(skip_mon_return < 0 ~ 0,
#                              TRUE ~ 1),
#          pos_sum = rollsum(pos_neg, 12,                    fill = NA,                    align = "right")) %>% 
#   slice(12:16)
# 
# # If the pos_sum is greater than or equal to 8, we label that period a 1. I'll call that label 
# # the consist_indicator
# 
# ret_tbl %>% 
#   slice(-1:-2) %>% 
#   mutate(pos_neg = case_when(skip_mon_return < 0 ~ 0,
#                              TRUE ~ 1),
#          pos_sum = rollsum(pos_neg, 12, fill = NA, align = "right"),
#          consist_indicator = case_when(pos_sum >= 8 ~ 1, 
#                                     TRUE ~ 0)) %>% 
#   select(Id, ym, skip_mon_return, pos_neg, pos_sum,                  consist_indicator, twelve_mon_return) %>% 
#   slice(12:16)


# We now have an indicator for the consistency of the momentum. We can code up an algorithm that # says if twelve_mon_return is positive and if consist_indicator is at least 8, then hold the 
# asset for the following month, and code that time period as 'quality'

# ret_tbl %>% 
#   slice(-1:-2) %>% 
#   mutate(pos_neg = case_when(skip_mon_return < 0 ~ 0,
#                              TRUE ~ 1),
#          pos_sum = rollsum(pos_neg, 12, fill = NA, align = "right"),
#          consist_indicator = case_when(pos_sum >= 8 ~ 1, 
#                                     TRUE ~ 0),
#          strat_returns = if_else(lag(twelve_mon_return) > 0 &                                        lag(consist_indicator) == 1,
#                                  mon_return, 0),
#          strat_label = if_else(lag(twelve_mon_return) > 0 &                               lag(consist_indicator) ==1,
#                                  "quality", "not_quality")) %>% 
#           na.omit()
# 
# 
# ret_tbl %>% 
#   slice(-1:-2) %>% 
#   mutate(pos_neg = case_when(skip_mon_return < 0 ~ 0,
#                              TRUE ~ 1),
#          pos_sum = rollsum(pos_neg, 12, fill = NA, align = "right"),
#          consist_indicator = case_when(pos_sum >= 8 ~ 1, 
#                                     TRUE ~ 0),
#          strat_returns = if_else(lag(twelve_mon_return) > 0 &                                  lag(consist_indicator) == 1,
#                                  mon_return, 0),
#          strat_label = if_else(lag(twelve_mon_return) > 0 &                               lag(consist_indicator) ==1,
#                                  "quality", "not_quality")) %>% 
#   na.omit() %>% 
#   count(strat_label) %>%         
#   mutate(prop = prop.table(n))
```

# Loading Libraries

```{r}
# loading libraries
library(data.table) # extension of the data.frame package. It is widely used for fast aggregation of large datasets, low latency add/update/remove of columns, quicker ordered joins, and a fast file reader.
library(dplyr) # data manipulation package
library(lubridate)
library(zoo) # methods for totally ordered indexed observations. It aims at performing calculations containing irregular time series of numeric vectors, matrices & factors

library(stats)
library(utils)
library(tidyverse)
library(readr)

```


# Loading in the R.data

Data column descriptions (Worldscope):
https://www.professors.wi.tum.de/fileadmin/w00bca/fm/Worldscope_Data_Definition_Guide_Issue_15.pdf

https://docs.google.com/spreadsheets/d/1YtuJiv60Q6nKIaFJLQY60sGQErbsl_8nvPdUHmvO8vM/edit?usp=sharing

Loading data Johannes
```{r}
memory.limit(9999999999)
# loading R.data BRIC monthly
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_monthly.RData")

# loading R.data BRIC static
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_static.RData")

# loading R.data BRIC yearly
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_yearly.RData")

```


Loading data Manuel
```{r}
# loading R.data BRIC monthly
load("/Users/Manu/Desktop/TUM_Master_Mgt_Technology/TUM_SS_21/Empirical Asset Pricing seminar/Seminar Thesis/BRIC_data/BRIC_monthly.RData")
# loading R.data BRIC monthly
load("/Users/Manu/Desktop/TUM_Master_Mgt_Technology/TUM_SS_21/Empirical Asset Pricing seminar/Seminar Thesis/BRIC_data/BRIC_static.RData")
# loading R.data BRIC monthly
load("/Users/Manu/Desktop/TUM_Master_Mgt_Technology/TUM_SS_21/Empirical Asset Pricing seminar/Seminar Thesis/BRIC_data/BRIC_yearly.RData")
```


# Data preparation


## 1 Save raw data and adjust date range

```{r}
#0 save raw data
BRIC.monthly.raw <- BRIC.monthly
BRIC.yearly.raw <- BRIC.yearly

#1 adjust date range (from July 1994 to December 2018)
#1.1 leave raw data with date adjustment
BRIC.monthly.withNA <- subset(BRIC.monthly.raw, Date >= "1994-06-30" & Date <= "2019-02-01")
BRIC.yearly.withNA <- subset(BRIC.yearly.raw, YEAR >= "1994" & YEAR <= "2019")
#1.2 working dataframe
BRIC.monthly <- subset(BRIC.monthly, Date >= "1994-06-30" & Date <= "2019-02-01")
BRIC.yearly <- subset(BRIC.yearly, YEAR >= "1994" & YEAR <= "2019")
```

## 2 BRIC.monthly data preparation
at this point of time the data sheet is still balanced, therefore we can use the shift function
```{r}
# add a new column for the lagged MV.USD (this is the MV.USD from the previous month) 
BRIC.monthly[, LMV.USD := lag((MV.USD),1), by =Id]

# add a new column for volatility
BRIC.monthly[, volatility := lag(rollapplyr(RET.USD, 36, sd, fill = NA, partial = 12),1), by =Id]

# add 12 new columns for last 12 months returns
BRIC.monthly[, lag1 := lag((RET.USD),1), by =Id]
BRIC.monthly[, lag2 := lag((RET.USD),2), by =Id]
BRIC.monthly[, lag3 := lag((RET.USD),3), by =Id]
BRIC.monthly[, lag4 := lag((RET.USD),4), by =Id]
BRIC.monthly[, lag5 := lag((RET.USD),5), by =Id]
BRIC.monthly[, lag6 := lag((RET.USD),6), by =Id]
BRIC.monthly[, lag7 := lag((RET.USD),7), by =Id]
BRIC.monthly[, lag8 := lag((RET.USD),8), by =Id]
BRIC.monthly[, lag9 := lag((RET.USD),9), by =Id]
BRIC.monthly[, lag10 := lag((RET.USD),10), by =Id]
BRIC.monthly[, lag11 := lag((RET.USD),11), by =Id]
BRIC.monthly[, lag12 := lag((RET.USD),12), by =Id]

# negative values are replaced to 0
#ifelse(BRIC.monthly$lag1<=0,0,ifelse(BRIC.monthly$lag1>0,1,NA))
BRIC.monthly$lag1 <- replace(BRIC.monthly$lag1,BRIC.monthly$lag1<=0,0)
BRIC.monthly$lag2 <- replace(BRIC.monthly$lag2,BRIC.monthly$lag2<=0,0)
BRIC.monthly$lag3 <- replace(BRIC.monthly$lag3,BRIC.monthly$lag3<=0,0)
BRIC.monthly$lag4 <- replace(BRIC.monthly$lag4,BRIC.monthly$lag4<=0,0)
BRIC.monthly$lag5 <- replace(BRIC.monthly$lag5,BRIC.monthly$lag5<=0,0)
BRIC.monthly$lag6 <- replace(BRIC.monthly$lag6,BRIC.monthly$lag6<=0,0)
BRIC.monthly$lag7 <- replace(BRIC.monthly$lag7,BRIC.monthly$lag7<=0,0)
BRIC.monthly$lag8 <- replace(BRIC.monthly$lag8,BRIC.monthly$lag8<=0,0)
BRIC.monthly$lag9 <- replace(BRIC.monthly$lag9,BRIC.monthly$lag9<=0,0)
BRIC.monthly$lag10 <- replace(BRIC.monthly$lag10,BRIC.monthly$lag10<=0,0)
BRIC.monthly$lag11 <- replace(BRIC.monthly$lag11,BRIC.monthly$lag11<=0,0)
BRIC.monthly$lag12 <- replace(BRIC.monthly$lag12,BRIC.monthly$lag12<=0,0)

# positive values are replaced to 1
BRIC.monthly$lag1 <- replace(BRIC.monthly$lag1,BRIC.monthly$lag1>0,1)
BRIC.monthly$lag2 <- replace(BRIC.monthly$lag2,BRIC.monthly$lag2>0,1)
BRIC.monthly$lag3 <- replace(BRIC.monthly$lag3,BRIC.monthly$lag3>0,1)
BRIC.monthly$lag4 <- replace(BRIC.monthly$lag4,BRIC.monthly$lag4>0,1)
BRIC.monthly$lag5 <- replace(BRIC.monthly$lag5,BRIC.monthly$lag5>0,1)
BRIC.monthly$lag6 <- replace(BRIC.monthly$lag6,BRIC.monthly$lag6>0,1)
BRIC.monthly$lag7 <- replace(BRIC.monthly$lag7,BRIC.monthly$lag7>0,1)
BRIC.monthly$lag8 <- replace(BRIC.monthly$lag8,BRIC.monthly$lag8>0,1)
BRIC.monthly$lag9 <- replace(BRIC.monthly$lag9,BRIC.monthly$lag9>0,1)
BRIC.monthly$lag10 <- replace(BRIC.monthly$lag10,BRIC.monthly$lag10>0,1)
BRIC.monthly$lag11 <- replace(BRIC.monthly$lag11,BRIC.monthly$lag11>0,1)
BRIC.monthly$lag12 <- replace(BRIC.monthly$lag12,BRIC.monthly$lag12>0,1)

BRIC.monthly$lagSum <- BRIC.monthly$lag1 + BRIC.monthly$lag2 + BRIC.monthly$lag3 + BRIC.monthly$lag4 + BRIC.monthly$lag5 + BRIC.monthly$lag6 + BRIC.monthly$lag7 + BRIC.monthly$lag8 + BRIC.monthly$lag9 + BRIC.monthly$lag10 + BRIC.monthly$lag11 + + BRIC.monthly$lag12

BRIC.monthly[ , pf.momentum := ifelse(lagSum>=8,"Winner",ifelse(lagSum < 8,"Looser",NA))]

# delete all entrys before July 1994
BRIC.monthly <- subset(BRIC.monthly, Date >= "1994-07-29" & Date <= "2019-02-01")

# calculate MV.USD.June for every column
# help columns
BRIC.monthly[,month := month(Date)]
BRIC.monthly[,year := year(Date)]
BRIC.monthly[,hcjun := ifelse(month>=7,year,year-1)]
# MV.USD.June column
intermediate <- filter(BRIC.monthly,BRIC.monthly$month == 7)
# minimise for join
intermediate <- subset(intermediate, select = c("Id","LMV.USD","hcjun"))
colnames(intermediate)[2] <- "MV.USD.June"
BRIC.monthly <- subset(BRIC.monthly, select = c("Id","country","Date","MV","MV.USD","LMV.USD","RET","RET.USD","volatility","pf.momentum","ym","hcjun","year","month"))

# inner join automatically deletes values where MV.USD.June is not available
BRIC.monthly <- inner_join(x = BRIC.monthly,y = intermediate, by = c("Id","hcjun"))
# order BRIC.monthly
BRIC.monthly <- subset(BRIC.monthly, select = c("Id","country","Date","MV","MV.USD","LMV.USD","MV.USD.June","RET","RET.USD","volatility","pf.momentum","ym","hcjun","year","month"))
```

## 2.1 Raw code to remove NAs (BRIC.monthly)

```{r}
# delete na's, set 0 and calculate important values
# no RET.USD data, no MV or no LMV.USD
BRIC.monthly <- BRIC.monthly %>%
  drop_na(RET.USD,MV,MV.USD,LMV.USD,MV.USD.June,volatility,pf.momentum)
```


## 3 BRIC.yearly data preparation and value calculation

```{r}
#3.0 the BRIC.yearly panel here is still balanced! We need to add a column for total assets the year before
#add the lagged WC03501 (shifted by Id) (this is the WC03501 from the previous month) 
BRIC.yearly[, lag.value:=c(0, WC03501[-.N]), by=Id] 
# rename column to LMV.USD
colnames(BRIC.yearly)[106] <- "TotalAssetsBefore"

#3.1 book value / equity and related
# delete rows with no WC03501 (Common equity)
BRIC.yearly <- BRIC.yearly %>%
  drop_na(WC03501)
# set WC03263 (deferred taxes) zero if NA
BRIC.yearly$WC03263 <- BRIC.yearly$WC03263 %>% replace_na(0)
# add column for BookValue (Hanauer 2020 calculation)
BRIC.yearly$BookValue <- BRIC.yearly$WC03501 + BRIC.yearly$WC03263
# delete rows with negative BookValue
BRIC.yearly <- BRIC.yearly[BRIC.yearly$BookValue >= 0,]

#3.2 total assets
# delete rows with no WC02999 (total assets)
BRIC.yearly <- BRIC.yearly %>%
  drop_na(WC02999)
# delete rows with no TotalAssetsBefore
BRIC.yearly <- BRIC.yearly %>%
  drop_na(TotalAssetsBefore)

#3.3 operating profits
# "To have a valid value, at least one of cost components cost of goods sold, selling, general and administrative expenses, or interest expense must be non-missing." (Hanauer, 2019, p. 284) --> if one of these values is missing, we must delete these rows WC01001,WC01051,WC01101,WC01251
# delete rows where ALL 4 columns are NA
BRIC.yearly <- filter(BRIC.yearly,!is.na(WC01001) | !is.na(WC01051) | !is.na(WC01101) | !is.na(WC01251))
# replace all na's in this 4 columns with 0
BRIC.yearly$WC01001 <- BRIC.yearly$WC01001 %>% replace_na(0)
BRIC.yearly$WC01051 <- BRIC.yearly$WC01051 %>% replace_na(0)
BRIC.yearly$WC01101 <- BRIC.yearly$WC01101 %>% replace_na(0)
BRIC.yearly$WC01251 <- BRIC.yearly$WC01251 %>% replace_na(0)
# calculate operating profits (Hanauer, 2019, p.284)
BRIC.yearly$OperatingProfits <- (BRIC.yearly$WC01001 - BRIC.yearly$WC01051 - BRIC.yearly$WC01101 - BRIC.yearly$WC01251)

# 3.4 minimise data frame
# for BRIC.yearly we keep: Id, country, ICBSUC, YEAR, BookValue, OperatingProfits and total assets
# Note: WC07201 is not used, as our MV should be the MV from the monthly data for 06.y !
BRIC.yearly <- subset(BRIC.yearly, select = c("Id","country","ICBSUC","YEAR","BookValue","OperatingProfits","WC02999","TotalAssetsBefore"))
# we rename WC02999 to total assets
colnames(BRIC.yearly)[7] <- "TotalAssets"

# 3.5 delete 1994 data (no accounting data for 1994 needed)
BRIC.yearly <- subset(BRIC.yearly, YEAR >= "1995" & YEAR <= "2019")

```

# 4 FF5FM Calculation
## 4.1 Adding the 1-m treasury rate to the monthly data
```{r}
# load data sheet from French's website
FFData <- read_csv("FF_Research_Data_5_Factors_2x3.CSV", 
     skip = 2)
# shorting data frame
one_m_tbill <- as.data.frame(FFData[c("X1","RF")][1:693,])
# adding a ym column to risk free rate data
one_m_tbill$ym<-as.yearmon(one_m_tbill$X1, "%Y %m")
#delete X1 column 
one_m_tbill <- subset(one_m_tbill,select = c("ym","RF"))
# merge risk-free rate (1 month treasury bill rate) with monthly data
BRIC.monthly <- left_join(x = BRIC.monthly, y = one_m_tbill, by = "ym")

# make rf column numeric
BRIC.monthly$RF <- as.numeric(BRIC.monthly$RF)

```

## 4.2 Calculate RMRF
```{r}
# USD RMRF
BRIC.monthly$RMRF <- BRIC.monthly$RET.USD - BRIC.monthly$RF
# Local currency RMRF
BRIC.monthly$RMRF.local <- BRIC.monthly$RET - BRIC.monthly$RF

```

## 4.3 Merge monthly and accounting (yearly) data
NOTE: Here we "loose" around 600 000 rows! 

```{r}
BRIC.maindata <- inner_join(x = BRIC.monthly,y = BRIC.yearly, by = c("Id","hcjun" = "YEAR"))

# Add a B/M column
BRIC.maindata$BM <- BRIC.maindata$BookValue / BRIC.maindata$MV
# Add a OP/BE column
BRIC.maindata$OPBE <- BRIC.maindata$OperatingProfits / BRIC.maindata$BookValue
# Add a AssetChange column
BRIC.maindata$AssetChange <- ((BRIC.maindata$TotalAssets - BRIC.maindata$TotalAssetsBefore)/BRIC.maindata$TotalAssetsBefore)
```

## 4.4 SMB: Determine size Breakpoints
```{r}
setorder(BRIC.maindata,Date,-MV.USD.June)
hlpvariable <-  BRIC.maindata[month==7 & !is.na(MV.USD.June),
                .(pf.size = ifelse((cumsum(MV.USD.June)/sum(MV.USD.June))>=0.9,"Small","Big"),Id),
                               by=year]

# Merge the size portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable,
                       by.x=c("hcjun","Id"),
                       by.y=c("year","Id"),
                       all.x=T)

# delete NA's (only about 1000 rows)
BRIC.maindata <- na.omit(BRIC.maindata,cols = "pf.size") 
```

RMRF used for benchmark in p.50 lecture slides
For annualisation we used arithmetic average * 12

## 4.4a Benchmark NOT Value Weighted 
```{r}
# create copy
BRIC.benchmark <- BRIC.maindata

# filter on pf.size
BRIC.benchmark <- filter(BRIC.benchmark,BRIC.benchmark$pf.size == "Big")

# BRIC
# per year
benchmark.retBricY <- aggregate(cbind(RET.USD,RMRF) ~ hcjun, data = BRIC.benchmark,FUN = mean)
benchmark.retBricY$RMRF <- benchmark.retBricY$RMRF * 12
benchmark.retBricY$RET.USD <- benchmark.retBricY$RET.USD * 12
# per month
benchmark.retBricM <- aggregate(cbind(RET.USD,RMRF) ~ ym + hcjun, data = BRIC.benchmark,FUN = mean)

# per country
# per year
benchmark.retCountryY <- aggregate(cbind(RET.USD,RMRF) ~ country.x + hcjun, data = BRIC.benchmark,FUN = mean)
benchmark.retCountryY$RMRF <- benchmark.retCountryY$RMRF * 12
benchmark.retCountryY$RET.USD <- benchmark.retCountryY$RET.USD * 12
# per month
benchmark.retCountryM <- aggregate(cbind(RET.USD,RMRF) ~ country.x + ym + hcjun, data = BRIC.benchmark,FUN = mean)

# single dataframe
benchmark_BRIC <- inner_join(benchmark.retBricY,benchmark.retBricM,by = "hcjun")
benchmark_Country <- inner_join(benchmark.retCountryY,benchmark.retCountryM,by = c("hcjun","country.x"))
# rename columns
colnames(benchmark_BRIC)[2] <- "YearlyReturn"
colnames(benchmark_BRIC)[3] <- "YearlyExcessReturn"
colnames(benchmark_BRIC)[5] <- "MonthlyReturn"
colnames(benchmark_BRIC)[6] <- "MonthlyExcessReturn"

colnames(benchmark_Country)[3] <- "YearlyReturn"
colnames(benchmark_Country)[4] <- "YearlyExcessReturn"
colnames(benchmark_Country)[6] <- "MonthlyReturn"
colnames(benchmark_Country)[7] <- "MonthlyExcessReturn"

```



## 4.4b Benchmark Value weighted

```{r}
# create copy
BRIC.benchmark <- BRIC.maindata

# filter on pf.size
BRIC.benchmark <- filter(BRIC.benchmark,BRIC.benchmark$pf.size == "Big")

# value weight returns
## calculate monthly market value over all stocks
BRIC.valueWeights <- aggregate(LMV.USD ~ ym, data = BRIC.benchmark, FUN = sum)
colnames(BRIC.valueWeights)[2] <- "TotalValue"

## join value weights to stocks
BRIC.benchmark <- inner_join(x = BRIC.benchmark, y = BRIC.valueWeights, by = "ym")

## calculate value weight
BRIC.benchmark$ValueWeight <- BRIC.benchmark$LMV.USD/BRIC.benchmark$TotalValue

## calculate value weight excess return / return
BRIC.benchmark$vwExRet <- BRIC.benchmark$ValueWeight * BRIC.benchmark$RMRF
BRIC.benchmark$vwRet <- BRIC.benchmark$ValueWeight*BRIC.benchmark$RET.USD

# per month
benchmark.retBricM <- aggregate(cbind(vwRet,vwExRet) ~ ym + hcjun, data = BRIC.benchmark,FUN = sum)

# per year
benchmark.retBricY <- aggregate(cbind(vwRet,vwExRet) ~ hcjun, data = benchmark.retBricM,FUN = mean)

## annualise
benchmark.retBricY$vwExRet <- benchmark.retBricY$vwExRet*12
benchmark.retBricY$vwRet <- benchmark.retBricY$vwRet*12

# per country
benchmark.retCountryM <- aggregate(cbind(vwRet,vwExRet) ~ country.x + ym + hcjun, data = BRIC.benchmark,FUN = sum)

# per year
benchmark.retCountryY <- aggregate(cbind(vwRet,vwExRet) ~ country.x + hcjun, data = benchmark.retCountryM,FUN = mean)

## annualise
benchmark.retCountryY$vwExRet <- benchmark.retCountryY$vwExRet*12
benchmark.retCountryY$vwRet <- benchmark.retCountryY$vwRet*12

# single dataframe
benchmark_BRIC <- inner_join(benchmark.retBricY,benchmark.retBricM,by = "hcjun")
benchmark_Country <- inner_join(benchmark.retCountryY,benchmark.retCountryM,by = c("hcjun","country.x"))
# rename columns
colnames(benchmark_BRIC)[2] <- "YearlyReturn"
colnames(benchmark_BRIC)[3] <- "YearlyExcessReturn"
colnames(benchmark_BRIC)[5] <- "MonthlyReturn"
colnames(benchmark_BRIC)[6] <- "MonthlyExcessReturn"

colnames(benchmark_Country)[3] <- "YearlyReturn"
colnames(benchmark_Country)[4] <- "YearlyExcessReturn"
colnames(benchmark_Country)[6] <- "MonthlyReturn"
colnames(benchmark_Country)[7] <- "MonthlyExcessReturn"
```



Breakpoints for RMW and CMA are based on Jiao(2017) and FF(2015) 2x3 sort = NYSE Percentiles (FF(2015) p.6)

![PortfolioSorts.] ("Images/PortfolioSorts.jpg")

##4.5 HML: Determine B/M breakpoints
```{r}
# Determine the B/M breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(BM) & pf.size=="Big", .(bm_bb30 = quantile(BM , probs = c(0.3), na.rm=T),
                                                                        bm_bb70 = quantile(BM , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the B/M portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.maindata[ , pf.bm := ifelse(BM>bm_bb70,"High",ifelse((BM<=bm_bb70 & BM>bm_bb30),"Neutral",ifelse(BM<=bm_bb30,"Low",NA)))]

BRIC.maindata[, SIZE_VALUE := paste0(pf.size,".",pf.bm)]
```

##4.6 RMW: Determine OP/BE breakpoints
```{r}
# Determine the OP/BE breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(OPBE) & pf.size=="Big", .(opbe_bb30 = quantile(OPBE , probs = c(0.3), na.rm=T),
                                                                        opbe_bb70 = quantile(OPBE , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the OP/BE portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

# 3 OP/BE brackets: Robust, Neutral and Weak
BRIC.maindata[ , pf.opbe := ifelse(OPBE>opbe_bb70,"Robust",ifelse((OPBE<=opbe_bb70 & OPBE>opbe_bb30),"Neutral",ifelse(OPBE<=opbe_bb30,"Weak",NA)))]

BRIC.maindata[, SIZE_PROFITABILITY := paste0(pf.size,".",pf.opbe)]

```

##4.7 Calculate CMA
investment: As in Cooper et al. (2008), we measure asset growth in June of year y as the percentage change in total assets (WC02999) from fiscal year ending in calendar year y−2 to fiscal year ending in calendar year y−1.
```{r}
# Determine the AC breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(AssetChange) & pf.size=="Big", .(ac_bb30 = quantile(AssetChange , probs = c(0.3), na.rm=T),
                                                                        ac_bb70 = quantile(AssetChange , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the AC portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

# 3 investment brackets: Aggressive, neutral and conservative
BRIC.maindata[ , pf.ac := ifelse(AssetChange>ac_bb70,"Aggressive",ifelse((AssetChange<=ac_bb70 & AssetChange>ac_bb30),"Neutral",ifelse(AssetChange<=ac_bb30,"Conservative",NA)))]

BRIC.maindata[, SIZE_INVESTMENT := paste0(pf.size,".",pf.ac)]
```


https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/Data_Library/f-f_5_factors_2x3.html

##4.8 Calculate Factors
```{r}

portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
  group_by(Date,SIZE_VALUE) %>% # do "everything" for the groups specified here
  summarize(ret.port = weighted.mean(RMRF,
                                     LMV.USD)) %>% # vw returns using lagged mcap
  spread(SIZE_VALUE,ret.port) %>% # create one column for each group
  mutate(
    Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
    Big = (Big.High + Big.Neutral + Big.Low)/3,
    SMB_HML = Small-Big,
    High = (Small.High + Big.High)/2,
    Low = (Small.Low + Big.Low)/2,
    HML = High-Low
  )

portfolio_hml <- as.data.table(portfolio_hml)

portfolio_rmw <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.opbe)] %>% # this operator nests functions
  group_by(Date,SIZE_PROFITABILITY) %>% # do "everything" for the groups specified here
  summarize(ret.port = weighted.mean(RMRF,
                                     LMV.USD)) %>% # vw returns using lagged mcap
  spread(SIZE_PROFITABILITY,ret.port) %>% # create one column for each group
  mutate(
    Small = (Small.Robust + Small.Neutral + Small.Weak)/3, # just exemplary
    Big = (Big.Robust + Big.Neutral + Big.Weak)/3,
    SMB_RMW = Small-Big,
    Robust = (Small.Robust + Big.Robust)/2,
    Weak = (Small.Weak + Big.Weak)/2,
    RMW = Robust - Weak
  )

portfolio_rmw <- as.data.table(portfolio_rmw)

portfolio_cma <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.ac)] %>% # this operator nests functions
  group_by(Date,SIZE_INVESTMENT) %>% # do "everything" for the groups specified here
  summarize(ret.port = weighted.mean(RMRF,
                                     LMV.USD)) %>% # vw returns using lagged mcap
  spread(SIZE_INVESTMENT,ret.port) %>% # create one column for each group
  mutate(
    Small = (Small.Aggressive + Small.Neutral + Small.Conservative)/3, # just exemplary
    Big = (Big.Aggressive + Big.Neutral + Big.Conservative)/3,
    SMB_CMA = Small-Big,
    Aggressive = (Small.Aggressive + Big.Aggressive)/2,
    Conservative = (Small.Conservative + Big.Conservative)/2,
    CMA = Conservative - Aggressive
  )

portfolio_cma <- as.data.table(portfolio_cma)

factors <- inner_join(x = portfolio_hml, y = portfolio_rmw, by = "Date")
factors <- inner_join(x = factors, y = portfolio_cma, by = "Date")
factors <- subset(factors, select = c("Date","CMA","HML","RMW","SMB_HML","SMB_RMW","SMB_CMA"))
factors$SMB <- ((factors$SMB_HML + factors$SMB_RMW + factors$SMB_CMA)/3)
factors <- subset(factors, select = c("Date","CMA","HML","RMW","SMB"))

summary(factors)
```


ISIN: International Security Identification Number (stock identifier)
ESTAT: active vs inactive company (publicly listed or not)
Id: join column with BRIC.yearly dataframe
INDM: industry sector code

GEOGN: geographic group name
GEOLN: geographic location

List of Database codes:
https://www.bwl.uni-mannheim.de/media/Lehrstuehle/bwl/Maug/Database_info/Datastream_dataypes.pdf

ID: ??
Country: 4 BRIC COUNTRY CODES
ICBSUC: industrial classification benchmark
https://link.springer.com/content/pdf/bbm%3A978-3-8350-9531-1%2F1.pdf

WC07021: SIC(standard industrial classification) primary code from Worldscope
W05651: Common Shares Traded - Annual (Security)


*TO DO's*:

- Calculate Benchmark (market-cap weighted big stocks of the BRIC region) || DONE
- Calculate break points on big stocks || DONE
- decide on strategy and implement it || WORKING
- calculate portfolio characteristics 
- visualize and showcase strategy performance
- regress strategy PF on FF5FM and momentum for style exposure analysis
- Literature || WIP
- sorting A-shares ... how to identify them? || DONE


*Project Dates*:
Thesis submission: June 21
Final presentation: June 07

*Strategy*:
GDP weighted countries; stock level: max sharpe ratio, min volatility, equal sector weights or quotas, momentum?

EDA

To DO: compute correlations by sector (10 sectors)

```{r}
# regular correlation matrix of all (four) numeric attributes
cor(select(BRIC.static, where(is.numeric)))
```

**Some conventions:**

Characteristic should be calculated as in Hanauer & Lauterbach (2019) or in Hanauer (2020)

Big stocks should be defined as the biggest stocks which together account for 90% of a
country's aggregated market capitalization
Benchmark should be defined as the cap-weighted universe of big stocks
Returns should be in USD
Breakpoints (for Fama-French factors) should be calculated on big stocks (as in the
excursus) but both small and big stocks go into the factor calculation.



#5.Multifactor Portfolio sort

Momentum sorting is done during #2.

##5.1 Value Breakpoints
```{r}
BRIC.strategy <- BRIC.maindata

colnames(BRIC.strategy)

## Value factor
## creating a large cap and high B/M ratio column (large cap value)

# subsetting the large cap stocks only (rebalanced yearly)
BRIC.strategy <- subset(BRIC.strategy, pf.size == "Big" )

# subsetting only value stocks (cutoff = median) Look up CUTOFF details
# Determine the value breakpoints
hlpvariable2 <- BRIC.maindata[month==7, .(median = quantile(BM , probs = c(0.5), na.rm=T)),by=year]
              
# Merge the value portfolio allocation back from July Y to June Y+1
BRIC.strategy <- merge(BRIC.strategy,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.strategy[ , pf.value := ifelse(BM>median,"Value",(ifelse(BM<=median,"Growth",NA)))]

table(BRIC.strategy$pf.value)
dim(BRIC.strategy)
```

##5.2 Low Vol
Strategy implementation on the balanced panel data (Multifactor etf)
```{r}

# Determine the low_vol breakpoints based on big stocks only
hlpvariable2 <- BRIC.strategy[month==7, .(lower_20 = quantile(volatility , probs = c(0.2), na.rm=T)),by=year]
              
# Merge the low_vol portfolio allocation back from July Y to June Y+1
BRIC.strategy <- merge(BRIC.strategy,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.strategy[ , pf.low_vol := ifelse(volatility>lower_20,"HighVol",(ifelse(volatility<=lower_20,"LowVol",NA)))]

table(BRIC.strategy$pf.low_vol)
dim(BRIC.strategy)

```
$$ Sharpe Ratio =  \frac{\mathbb{E}[R_p] - R_f}{\sigma_p} $$



##5.3 Filtering for strategy requirements
```{r}
# filtering for growth stocks
BRIC.strategy <- subset(BRIC.strategy, pf.value == "Growth" )

# filtering for lowVol stocks
BRIC.strategy <- subset(BRIC.strategy, pf.low_vol == "LowVol" )

# filtering for winner stocks
BRIC.strategy <- subset(BRIC.strategy, pf.momentum  == "Winner" )

dim(BRIC.strategy)

summary(BRIC.strategy)
```

#6 Calculating portfolio characteristics

All teams should perform the following analyses:

- A clear description of the strategy design (approach, weighting, rebalancing,...)
- Portfolio characteristics (ann. turnover, avg. number of stocks, portfolio concentration)
- Performance statistics (return, volatility, Sharpe ratio, outperformance, tracking error,
information ratio, all annualized)
- Visualize cumulative performance and outperformance
- Regress portfolio performance on FF5FM + Momentum for style analysis
- Provide the time-series of the your strategy, the benchmark, and Fama-French factors as
RData file

## 6.1 Annualized PF returns 

Brainstorming:

- annualized mean return (portfolio + by country)

```{r}

# entire BRIC region returns (arithmetic average *12)
# per year
strategy.retBricY <- aggregate(cbind(RMRF,RET.USD) ~ hcjun, data = BRIC.strategy,FUN = mean)
strategy.retBricY$RMRF <- strategy.retBricY$RMRF * 12 # annualization of excess returns
strategy.retBricY$RET.USD <- strategy.retBricY$RET.USD * 12 # ann. of regular returns
# per month
strategy.retBricM <- aggregate(RMRF ~ ym + hcjun, data = BRIC.strategy,FUN = mean)


# calculating the std of the annualized returns
sd_pf <- sd(strategy.retBricY$RET.USD) # 35.63418

# calculating the mean of the 24 years of annualized returns
mean_ret_pf <- mean(strategy.retBricY$RET.USD)

mean_ret_pf # 15.59512 %



# SHARPE RATIO

# mean excess return
mean_rmrf_portfolio <- mean(strategy.retBricY$RMRF)

sr_pf <- mean_rmrf_portfolio/sd_pf

sr_pf # 0.3736825

# Max Drawdown 

v <- cumprod(1 + BRIC.strategy$RET.USD/100)  # returns
1 - v/cummax(v)         ## drawdown
max(1 - v/cummax(v))    ## max. drawdown

# TRACKING ERROR

# merge portfolio returns and benchmark returns
portfolio_benchmark <- inner_join(x = strategy.retBricY, y = benchmark.retBricY, by = "hcjun")
colnames(portfolio_benchmark)[2] <- "RMRF_pf"
colnames(portfolio_benchmark)[3] <- "RET.USD_pf"
colnames(portfolio_benchmark)[4] <- "RMRF_benchm"
colnames(portfolio_benchmark)[5] <- "RET.USD_benchm"
portfolio_benchmark$pf_activeReturn <- portfolio_benchmark$RET.USD_pf - portfolio_benchmark$RET.USD_benchm
tracking_error <- sd(portfolio_benchmark$pf_activeReturn)

tracking_error # 23.30507 %

# INFORMATION RATIO (PF's avg active return over the tracking error)

ir_pf <- mean(portfolio_benchmark$pf_activeReturn)/tracking_error

ir_pf # 0.3075918



# per country returns
# per year
strategy.retCountryY <- aggregate(RMRF ~ country.x + hcjun, data = BRIC.strategy,FUN = mean)
strategy.retCountryY$RMRF <- strategy.retCountryY$RMRF * 12 #annualizing the returns
# per month
strategy.retCountryM <- aggregate(RMRF ~ country.x + ym + hcjun, data = BRIC.strategy,FUN = mean)

# single dataframe
strategy_BRIC <- inner_join(strategy.retBricY,strategy.retBricM,by = "hcjun")
strategy_Country <- inner_join(strategy.retCountryY,strategy.retCountryM,by = c("hcjun","country.x"))
# rename columns
colnames(strategy_BRIC)[2] <- "YearlyExcessReturn"
colnames(strategy_BRIC)[4] <- "MonthlyExcessReturn"
colnames(strategy_Country)[3] <- "YearlyExcessReturn"
colnames(strategy_Country)[5] <- "MonthlyExcessReturn"

# annualized mean excess return for the entire period by country
strategy.total_retCountryY <- aggregate(RMRF ~ country.x, data=strategy.retCountryY, FUN=mean)

strategy.total_retCountryY

# annualized mean excess return for the entire period for the entire PF (GDP weights)

wt <- c(0.13, 0.60,0.17,0.10) # GDP weights (BRA, CHN, IND, RUS) 2017 GDP weights
x <- c(strategy.total_retCountryY[,2]) # mean returns (BRA, CHN, IND, RUS)

pf_mean_ex_return_gdp <- weighted.mean(x, wt)

pf_mean_ex_return_gdp # 18.50333 % p.a.

# annualized mean excess return for the entire period for the entire PF (GDP weights)

wt <- c(0.25, 0.25,0.25,0.25) # GDP weights (BRA, CHN, IND, RUS) 2017 GDP weights
x <- c(strategy.total_retCountryY[,2]) # mean returns (BRA, CHN, IND, RUS)

pf_mean_ex_return_ew <- weighted.mean(x, wt)

pf_mean_ex_return_ew # 18.1691 % p.a.

# average number of stocks in the PF over time period

intermediate_df <- BRIC.strategy %>% select(c("Id","year"))

strategy.no_stocks <- aggregate(Id ~year, data=intermediate_df, FUN=function(x) length(unique(x)))

strategy.no_stocks # dataframe with no of stocks by year (for the entire BRIC region)

mean(strategy.no_stocks$Id) # 99.56522 (average # of stocks per year)

## extra info : by country and by year

intermediate_df <- BRIC.strategy %>% select(c("Id","year","country.x"))

strategy.no_stocks_by_country <- aggregate(Id ~year+country.x, data=intermediate_df, FUN=function(x) length(unique(x)))

strategy.no_stocks_by_country

# annualized std per year (weight per stock * stdev per stock )

intermediate_df <- BRIC.strategy %>% select(c("Id","year","volatility"))

# annualized volatility by stock per time point
BRIC.strategy$vol_an <- BRIC.strategy$volatility*sqrt(12)

total_sd_pf <- B


# covariance matrix for the stock returns ()




# annualized mean excess return for the entire period for the entire PF (GDP weights)

wt <- c(0.25, 0.25,0.25,0.25) # GDP weights (BRA, CHN, IND, RUS) 2017 GDP weights
x <- c(strategy.total_retCountryY[,2]) # mean returns (BRA, CHN, IND, RUS)

pf_mean_ex_return_ew <- weighted.mean(x, wt)


# plot of the excess returns 
a <- ggplot(data = strategy_BRIC) + geom_line(aes(x = ym, y = MonthlyExcessReturn)) + geom_line(aes(x = ym, y = YearlyExcessReturn, color="red"))
a
```


## 5.6 Loading GDP Data
```{r}
# load data sheet from French's website
GDPData <- read_csv("GDP_raw_data.csv", 
     skip = 3)

# rename column
colnames(GDPData)[2] <- "CountryCode"

# filter on BRIC countries
GDPData <- GDPData %>% filter(CountryCode == "IND" | CountryCode == "CHN" | CountryCode == "BRA" | CountryCode == "RUS")

# transpose data frame and keep row names
GDPData <- as.data.frame(t(GDPData))
setDT(GDPData, keep.rownames = TRUE)[]

colnames(GDPData)[1] <- "year"
colnames(GDPData)[2] <- "BRA"
colnames(GDPData)[3] <- "CHN"
colnames(GDPData)[4] <- "IND"
colnames(GDPData)[5] <- "RUS"

# shorting data frame
GDPData <- GDPData %>% filter(year >= 1994 & year < 2020 )

class(GDPData$BRA)

# convert factor type objects to numeric objects
GDPData$BRA <- as.numeric(as.character(GDPData$BRA))
GDPData$CHN <- as.numeric(as.character(GDPData$CHN))
GDPData$IND <- as.numeric(as.character(GDPData$IND))
GDPData$RUS <- as.numeric(as.character(GDPData$RUS))
GDPData$year <- as.numeric(as.character(GDPData$year))

# get the sum of all GDPs
GDPData$SumOfGDP <- GDPData$BRA + GDPData$CHN + GDPData$IND + GDPData$RUS

# get % of total GDP per country
GDPData$BRA_w <- GDPData$BRA/GDPData$SumOfGDP
GDPData$CHN_w <- GDPData$CHN/GDPData$SumOfGDP
GDPData$IND_w <- GDPData$IND/GDPData$SumOfGDP
GDPData$RUS_w <- GDPData$RUS/GDPData$SumOfGDP



# plot of GDP weights over time
overview <- ggplot(data = GDPData, aes(x = year)) + 
  geom_line(aes(y = BRA_w, colour="BRA_w")) + 
  geom_line(aes(y = CHN_w, colour="CHN_w")) + 
  geom_line(aes(y = IND_w, colour="IND_w")) + 
  geom_line(aes(y = RUS_w, colour="RUS_w")) + 
  labs(y= "country weight", x = "Year", title ="GDP weights by country over time") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Country weight", 
                      breaks = c("BRA_w", "CHN_w", "IND_w", "RUS_w"),
                      values = c("red", "green", "blue","orange"))
  
overview

```


```{r}
# factor return plots
library(ggplot2)


cma.zoo <- zoo(factors$CMA) # zoo object

factors$cma.cum_ret = cumsum(log(1+cma.zoo/100)) # cum log returns

hml.zoo <- zoo(factors$HML)

factors$hml.cum_ret = cumsum(log(1+hml.zoo/100))

rmw.zoo <- zoo(factors$RMW)

factors$rmw.cum_ret = cumsum(log(1+rmw.zoo/100))

smb.zoo <- zoo(factors$SMB)

factors$smb.cum_ret = cumsum(log(1+smb.zoo/100))



# creating a dataframe for plotting the cummulative returns
df_new <- data.frame(cma.cret = as.vector(factors$cma.cum_ret),
                     smb.cret = as.vector(factors$smb.cum_ret),
                     hml.cret = as.vector(factors$hml.cum_ret),
                     rmw.cret = as.vector(factors$rmw.cum_ret),
                     time = as.Date(factors$Date))

# plot of the factor returns (log scale)
cum_rets <- ggplot(data = df_new, aes(x = time))   +
  geom_line(aes(y = smb.cret, colour="smb.cret")) + 
  geom_line(aes(y = hml.cret, colour="hml.cret")) +
  geom_line(aes(y = rmw.cret, colour="rmw.cret")) + 
  geom_line(aes(y = cma.cret, colour="cma.cret")) + 
  labs(y= "cum. log return", x = "Year", title ="Monthly cum. factor log returns") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Factor", 
                      breaks = c("smb.cret", "hml.cret", "rmw.cret", "cma.cret"),
                      values = c("red", "green", "blue","orange"))
  
cum_rets
 

# factor returns (regular scale)
factor_returns <- ggplot(data = factors, aes(x = Date)) + 
  geom_line(aes(y = SMB, colour="SMB")) + 
  geom_line(aes(y = HML, colour="HML")) + 
  geom_line(aes(y = RMW, colour="RMW")) + 
  geom_line(aes(y = CMA, colour="CMA")) + 
  labs(y= "country weight", x = "Year", title ="Monthly factor returns") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Country weight", 
                      breaks = c("SMB", "HML", "RMW", "CMA"),
                      values = c("red", "green", "blue","orange"))
  
factor_returns



```


```{r}
# Strategy vs benchmark plots

dim(benchmark.retBricM)

dim(strategy.retBricM)

# inner join 
bm_plot_df <- inner_join(x=benchmark.retBricM, y=strategy.retBricM, by="ym")

bm_plot_df

# zoo objects for cummulative performance 
benchmark.zoo <- zoo(bm_plot_df$RMRF.x) # zoo object

# cummulative performance of 1 EUR
bm_plot_df$bm.cum_ret = cumsum(log(1+benchmark.zoo/100)) # cum log returns

strategy.zoo <- zoo(bm_plot_df$RMRF.y)

bm_plot_df$strat.cum_ret = cumsum(log(1+strategy.zoo/100))



# creating a dataframe for plotting the cummulative returns
df_new <- data.frame(bm.cret = as.vector(bm_plot_df$bm.cum_ret),
                     strat.cret = as.vector(bm_plot_df$strat.cum_ret),
                     time = bm_plot_df$ym)

# strategy returns vs big stocks benchmark 
strategy_vs_bm_returns <- ggplot(data = bm_plot_df, aes(x = ym)) + 
  geom_line(aes(y = bm.cum_ret, colour="bm.cum_ret")) + 
  geom_line(aes(y = strat.cum_ret, colour="strat.cum_ret")) + 
  labs(y= "cummulative performance", x = "Year", title ="Monthly excess returns Strategy vs Benchmark") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Portfolio", 
                      breaks = c("bm.cum_ret", "strat.cum_ret"),
                      labels= c("Benchmark","Strategy"), # legend label names
                      values = c("red", "green"))
  
strategy_vs_bm_returns

```



# 7 Spanning tests (factor exposure)

TO DO: 
- do tests by country too
- replace RMRF by RMRF.local

```{r}
# correlation matrix between factors

head(factors)

dim(factors) # 280 (24 years * 12 months) x 5

cor(factors[,-"Date"]) # correlation matrix between factors for the BRIC region

summary(factors) # to use for a table

## Spanning Tests
# Check if WML is spanned by the FF3FM
##Data_Excursus3a[,summary(lm(WML ~ RMRF.local + SMB + HML))]
summary(lm(data=factors, formula = WML ~ RMRF + SMB + HML))

# Check if WML is spanned by the FF5FM
##Data_Excursus3a[,summary(lm(WML ~ RMRF.local + SMB + HML + CMA + RMW))]
summary(lm(data=Data_Excursus3a, formula = WML ~ RMRF.local + SMB + HML + CMA + RMW))

# Check if WML is spanned by the FF3FM with HML_d
##Data_Excursus3a[,summary(lm(WML ~ RMRF.local + SMB + HML.devil))]
summary(lm(data=Data_Excursus3a, formula = WML ~ RMRF.local + SMB + HML.devil))

# correlation test between paired samples
##Data_Excursus3a[,cor.test(WML,HML.devil)]
cor.test(Data_Excursus3a$WML,Data_Excursus3a$HML.devil)

# Check if Value is spanned by FF3F + WML
##Data_Excursus3a[,summary(lm(HML ~ RMRF.local + SMB + WML))]
summary(lm(data=Data_Excursus3a, formula = HML ~ RMRF.local + SMB + WML))

##Data_Excursus3a[,summary(lm(HML.devil ~ RMRF.local + SMB + WML))]
summary(lm(data=Data_Excursus3a, formula = HML.devil ~ RMRF.local + SMB + WML))

```


