---
title: "BRIC_project"
author: 
  name: Manuel Schreiber
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
    df_print: paged
  html_notebook: default
  latex_engine: pdflatex
  pdf_document: default
  header-includes:
   - \usepackage{amsmath}
   - \usepackage{amsfonts}
---

**BRIC Project**

```{r}
# clear workspace
##rm(list=ls())
```


getting the current WD

```{r}
getwd()
```

changing the WD

```{r}
##setwd("/Users/Manu/Desktop/TUM_Master_Mgt_Technology/TUM_SS_21/Empirical Asset Pricing seminar/Seminar Thesis/BRIC_data")
```

# Loading Libraries

```{r}
# loading libraries
library(data.table) # extension of the data.frame package. It is widely used for fast aggregation of large datasets, low latency add/update/remove of columns, quicker ordered joins, and a fast file reader.
library(dplyr) # data manipulation package
library(lubridate)
library(zoo) # methods for totally ordered indexed observations. It aims at performing calculations containing irregular time series of numeric vectors, matrices & factors

library(stats)
library(utils)
library(tidyverse)
library(readr)

```


# Loading in the R.data

Data column descriptions (Worldscope):
https://www.professors.wi.tum.de/fileadmin/w00bca/fm/Worldscope_Data_Definition_Guide_Issue_15.pdf

https://docs.google.com/spreadsheets/d/1YtuJiv60Q6nKIaFJLQY60sGQErbsl_8nvPdUHmvO8vM/edit?usp=sharing


```{r}
memory.limit(9999999999)
# loading R.data BRIC monthly
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_monthly.RData")

# loading R.data BRIC static
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_static.RData")

# loading R.data BRIC yearly
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_yearly.RData")

```
# Data preparation

## 1 Save raw data and adjust date range

```{r}
#0 save raw data
BRIC.monthly.raw <- BRIC.monthly
BRIC.yearly.raw <- BRIC.yearly

#1 adjust date range (from July 1994 to December 2018)
#1.1 leave raw data with date adjustment
BRIC.monthly.withNA <- subset(BRIC.monthly.raw, Date >= "1994-06-30" & Date <= "2019-02-01")
BRIC.yearly.withNA <- subset(BRIC.yearly.raw, YEAR >= "1994" & YEAR <= "2019")
#1.2 working dataframe
BRIC.monthly <- subset(BRIC.monthly, Date >= "1994-06-30" & Date <= "2019-02-01")
BRIC.yearly <- subset(BRIC.yearly, YEAR >= "1994" & YEAR <= "2019")
```

## 2 BRIC.monthly data preparation
at this point of time the data sheet is still balanced, therefore we can use the shift function
```{r}
#add the lagged MV.USD (this is the MV.USD from the previous month) 
BRIC.monthly[, lag.value:=c(1, MV.USD[-.N]), by=Id]
# rename column to LMV.USD
colnames(BRIC.monthly)[14] <- "LMV.USD"
#delete entry for "1994-06-30" as lag-value is wrong and this data point not needed
BRIC.monthly <- subset(BRIC.monthly, Date >= "1994-07-29" & Date <= "2019-02-01")

# calculate MV.USD.June for every column
# help columns
BRIC.monthly[,month := month(Date)]
BRIC.monthly[,year := year(Date)]
BRIC.monthly[,hcjun := ifelse(month>=7,year,year-1)]
# MV.USD.June column
intermediate <- filter(BRIC.monthly,BRIC.monthly$month == 7)
# minimise for join
intermediate <- subset(intermediate, select = c("Id","LMV.USD","hcjun"))
colnames(intermediate)[2] <- "MV.USD.June"
BRIC.monthly <- subset(BRIC.monthly, select = c("Id","country","Date","MV","MV.USD","LMV.USD","RET","RET.USD","ym","hcjun","year","month"))
#delete na's, set 0 and calculate important values
# no RET.USD data, no MV or no LMV.USD
BRIC.monthly <- BRIC.monthly %>%
  drop_na(RET.USD,MV,MV.USD,LMV.USD)
intermediate <- intermediate %>%
  drop_na(MV.USD.June)
# inner join automatically deletes values where MV.USD.June is not available
BRIC.monthly <- inner_join(x = BRIC.monthly,y = intermediate, by = c("Id","hcjun"))
# order BRIC.monthly
BRIC.monthly <- subset(BRIC.monthly, select = c("Id","country","Date","MV","MV.USD","LMV.USD","MV.USD.June","RET","RET.USD","ym","hcjun","year","month"))
```

## 3 BRIC.yearly data preparation and value calculation
```{r}
#3.0 the BRIC.yearly panel here is still balanced! We need to add a column for total assets the year before
#add the lagged WC03501 (this is the WC03501 from the previous month) 
BRIC.yearly[, lag.value:=c(0, WC03501[-.N]), by=Id]
# rename column to LMV.USD
colnames(BRIC.yearly)[106] <- "TotalAssetsBefore"

#3.1 book value / equity and related
# delete rows with no WC03501 (Common equity)
BRIC.yearly <- BRIC.yearly %>%
  drop_na(WC03501)
# set WC03263 (deferred taxes) zero if NA
BRIC.yearly$WC03263 <- BRIC.yearly$WC03263 %>% replace_na(0)
# add column for BookValue (Hanauer 2020 calculation)
BRIC.yearly$BookValue <- BRIC.yearly$WC03501 + BRIC.yearly$WC03263
# delete rows with negative BookValue
BRIC.yearly <- BRIC.yearly[BRIC.yearly$BookValue >= 0,]

#3.2 total assets
# delete rows with no WC02999 (total assets)
BRIC.yearly <- BRIC.yearly %>%
  drop_na(WC02999)
# delete rows with no TotalAssetsBefore
BRIC.yearly <- BRIC.yearly %>%
  drop_na(TotalAssetsBefore)

#3.3 operating profits
# "To have a valid value, at least one of cost components cost of goods sold, selling, general and administrative expenses, or interest expense must be non-missing." (Hanauer, 2019, p. 284) --> if one of these values is missing, we must delete these rows WC01001,WC01051,WC01101,WC01251
# delete rows where ALL 4 columns are NA
BRIC.yearly <- filter(BRIC.yearly,!is.na(WC01001) | !is.na(WC01051) | !is.na(WC01101) | !is.na(WC01251))
# replace all na's in this 4 columns with 0
BRIC.yearly$WC01001 <- BRIC.yearly$WC01001 %>% replace_na(0)
BRIC.yearly$WC01051 <- BRIC.yearly$WC01051 %>% replace_na(0)
BRIC.yearly$WC01101 <- BRIC.yearly$WC01101 %>% replace_na(0)
BRIC.yearly$WC01251 <- BRIC.yearly$WC01251 %>% replace_na(0)
# calculate operating profits (Hanauer, 2019, p.284)
BRIC.yearly$OperatingProfits <- (BRIC.yearly$WC01001 - BRIC.yearly$WC01051 - BRIC.yearly$WC01101 - BRIC.yearly$WC01251)

# 3.4 minimise data frame
# for BRIC.yearly we keep: Id, country, ICBSUC, YEAR, BookValue, OperatingProfits and total assets
# Note: WC07201 is not used, as our MV should be the MV from the monthly data for 06.y !
BRIC.yearly <- subset(BRIC.yearly, select = c("Id","country","ICBSUC","YEAR","BookValue","OperatingProfits","WC02999","TotalAssetsBefore"))
# we rename WC02999 to total assets
colnames(BRIC.yearly)[7] <- "TotalAssets"

#3.5 delete 1994 data
BRIC.yearly <- subset(BRIC.yearly, YEAR >= "1995" & YEAR <= "2019")

```

# 4 FF5FM Calculation
## 4.1 Adding the 1-m treasury rate to the monthly data
```{r}
# load data sheet from French's website
FFData <- read_csv("FF_Research_Data_5_Factors_2x3.CSV", 
     skip = 2)
# shorting data frame
one_m_tbill <- as.data.frame(FFData[c("X1","RF")][1:693,])
# adding a ym column to risk free rate data
one_m_tbill$ym<-as.yearmon(one_m_tbill$X1, "%Y %m")
#delete X1 column 
one_m_tbill <- subset(one_m_tbill,select = c("ym","RF"))
# merge risk-free rate (1 month treasury bill rate) with monthly data
BRIC.monthly <- left_join(x = BRIC.monthly, y = one_m_tbill, by = "ym")

# make rf column numeric
BRIC.monthly$RF <- as.numeric(BRIC.monthly$RF)

```

## 4.2 Calculate RMRF
```{r}
BRIC.monthly$RMRF <- BRIC.monthly$RET.USD - BRIC.monthly$RF
```

## 4.3 Merge monthly and accounting (yearly) data
NOTE: Here we "loose" around 600 000 rows! 

```{r}
BRIC.maindata <- inner_join(x = BRIC.monthly,y = BRIC.yearly, by = c("Id","hcjun" = "YEAR"))
```

## 4.4 SMB: Determine size Breakpoints
```{r}
setorder(BRIC.maindata,Date,-MV.USD.June)
hlpvariable <-  BRIC.maindata[month==7 & !is.na(MV.USD.June),
                .(pf.size = ifelse((cumsum(MV.USD.June)/sum(MV.USD.June))>=0.9,"Small","Big"),Id),
                               by=year]

# Merge the size portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable,
                       by.x=c("hcjun","Id"),
                       by.y=c("year","Id"),
                       all.x=T)

# delete NA's (only about 1000 rows)
BRIC.maindata <- na.omit(BRIC.maindata,cols = "pf.size") 
```

## 4.5 HML: Determine B/M breakpoints
```{r}
# Add a B/M column
BRIC.maindata$BM <- BRIC.maindata$BookValue / BRIC.maindata$MV.USD

# Determine the B/M breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(BM) & pf.size=="Big", .(bm_bb30 = quantile(BM , probs = c(0.3), na.rm=T),
                                                                        bm_bb70 = quantile(BM , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the B/M portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.maindata[ , pf.bm := ifelse(BM>bm_bb70,"High",ifelse((BM<=bm_bb70 & BM>bm_bb30),"Neutral",ifelse(BM<=bm_bb30,"Low",NA)))]

BRIC.maindata[, SIZE_VALUE := paste0(pf.size,".",pf.bm)]
```

# 4.6 RMW: Determine OP/BE breakpoints
```{r}
# Add a OP/BE column
BRIC.maindata$OPBE <- BRIC.maindata$OperatingProfits / BRIC.maindata$BookValue

# Determine the OP/BE breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(OPBE) & pf.size=="Big", .(opbe_bb30 = quantile(OPBE , probs = c(0.3), na.rm=T),
                                                                        opbe_bb70 = quantile(OPBE , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the OP/BE portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.maindata[ , pf.opbe := ifelse(OPBE>opbe_bb70,"Robust",ifelse((OPBE<=opbe_bb70 & OPBE>opbe_bb30),"Neutral",ifelse(OPBE<=opbe_bb30,"Weak",NA)))]

BRIC.maindata[, SIZE_PROFITABILITY := paste0(pf.size,".",pf.opbe)]

```

TASK! CHECK! Check with Cooper (2008) and FF(2015) what conservative and what aggressive is!
# 4.7 Calculate CMA
investment: As in Cooper et al. (2008), we measure asset growth in June of year y as the percentage change in total assets (WC02999) from fiscal year ending in calendar year y−2 to fiscal year ending in calendar year y−1.
```{r}
# Add a AssetChange column
BRIC.maindata$AssetChange <- ((BRIC.maindata$TotalAssets - BRIC.maindata$TotalAssetsBefore)/BRIC.maindata$TotalAssetsBefore)

# Determine the AC breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(AssetChange) & pf.size=="Big", .(ac_bb30 = quantile(AssetChange , probs = c(0.3), na.rm=T),
                                                                        ac_bb70 = quantile(AssetChange , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the AC portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.maindata[ , pf.ac := ifelse(AssetChange>ac_bb70,"Aggressive",ifelse((AssetChange<=ac_bb70 & AssetChange>ac_bb30),"Neutral",ifelse(AssetChange<=ac_bb30,"Conservative",NA)))]

BRIC.maindata[, SIZE_INVESTMENT := paste0(pf.size,".",pf.ac)]

```

## 4.8 Calculate Factors (working on it)
```{r}
portfolio_returns <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
  group_by(Date,SIZE_VALUE) %>% # do "everything" for the groups specified here
  summarize(ret.port = weighted.mean(RET.USD,
                                     LMV.USD)) %>% # vw returns using lagged mcap
  spread(SIZE_VALUE,ret.port) %>% # create one column for each group
  mutate(
    Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
    Big = (Big.High + Big.Neutral + Big.Low)/3,
    SMB = Small-Big,
    High = (Small.High + Big.High)/2,
    Low = (Small.Low + Big.Low)/2,
    HML = High-Low
  )

portfolio_returns <- as.data.table(portfolio_returns)
 
```


ISIN: International Security Identification Number (stock identifier)
ESTAT: active vs inactive company (publicly listed or not)
Id: join column with BRIC.yearly dataframe
INDM: industry sector code

GEOGN: geographic group name
GEOLN: geographic location

List of Database codes:
https://www.bwl.uni-mannheim.de/media/Lehrstuehle/bwl/Maug/Database_info/Datastream_dataypes.pdf

ID: ??
Country: 4 BRIC COUNTRY CODES
ICBSUC: industrial classification benchmark
https://link.springer.com/content/pdf/bbm%3A978-3-8350-9531-1%2F1.pdf

WC07021: SIC(standard industrial classification) primary code from Worldscope
W05651: Common Shares Traded - Annual (Security)


*TO DO's*:

- Calculate Benchmark (market-cap weighted big stocks of the BRIC region)
- Calculate break points on big stocks
- decide on strategy and implement it
- calculate portfolio characteristics
- visualize and showcase strategy performance
- regress strategy PF on FF5FM and momentum for style exposure analysis
- Literature
- sorting A-shares ... how to identify them?


*Project Dates*:
Thesis submission: June 21
Final presentation: June 07

*Strategy*:
GDP weighted countries; stock level: max sharpe ratio, min volatility, equal sector weights or quotas, momentum?


EDA

```{r}
# finding the number of NA values by column in the dataframe
BRIC.monthly %>% mutate_all(is.na) %>% summarize_all(sum)

```

To DO: compute correlations by sector (10 sectors)

```{r}
# regular correlation matrix of all (four) numeric attributes
cor(select(BRIC.static, where(is.numeric)))
```


**Some conventions:**

Characteristic should be calculated as in Hanauer & Lauterbach (2019) or in Hanauer (2020)

Big stocks should be defined as the biggest stocks which together account for 90% of a
country's aggregated market capitalization
Benchmark should be defined as the cap-weighted universe of big stocks
Returns should be in USD
Breakpoints (for Fama-French factors) should be calculated on big stocks (as in the
excursus) but both small and big stocks go into the factor calculation.

# Benchmark Calculation

```{r}
length(BRIC.static$Id)

length(BRIC.yearly$Id)

```

```{r}
# joining the monthly and the static dataframe by the Id column (retainig all rows of BRIC.yearly)
df_combined <- left_join(x=BRIC.monthly,y=BRIC.static,by="Id")


head(df_combined)



```

```{r}
summary(df_combined$MV.USD)
```


```{r}
## finding the number of NA values by column in the dataframe
BRIC.yearly %>% mutate_all(is.na) %>% summarize_all(sum)
```



```{r}
# markt cap (USD): WC07210

## finding the number of NA values by column in the dataframe
df_combined %>% mutate_all(is.na) %>% summarize_all(sum)
```




Idea: calculate 90% of the sum of all stock market caps per country as a time series
(store the result in a column )

```{r}
# Big stocks should be defined as the biggest stocks which together account for 90% of # a country's aggregated market capitalization


# grouping the mcap values of individual stocks by country
mcap_country <- df_combined %>%
  filter(df_combined$MV.USD != "NA") %>% 
  group_by(country.x, ym) 

# computing the sum of the individual stock's market caps by country
country_mcap <- mcap_country %>%
group_by(country.x, ym) %>%
    summarize(mc_sum = sum(MV.USD))

country_mcap


```

```{r}
summary(country_mcap$mc_sum[country_mcap$country.x == "BRA"])
summary(country_mcap$mc_sum[country_mcap$country.x == "RUS"])
summary(country_mcap$mc_sum[country_mcap$country.x == "IND"])
summary(country_mcap$mc_sum[country_mcap$country.x == "CHN"])
```


# Strategy


```{r}
#install.packages("plm")
library(plm)
library(dplyr)

#strategy_df <- pdata.frame(BRIC.monthly,index = c("Id","ym"))

### time series calculation pending

# calculate sd of return by ym
sd_help <- subset(BRIC.monthly,select = c("Id","ym","RET.USD"))
sd_help <- na.omit(sd_help,cols = RET.USD) # may be deleted, if redundant

# monthly basis
number_of_stocks <- aggregate(.~ ym, data = sd_help,FUN = NROW) # alternative: sd_help %>% count(ym)
mean_return <- aggregate(RET.USD ~ ym, data = sd_help,FUN = mean)
sd_return <- aggregate(RET.USD ~ ym, data = sd_help, FUN = sd)
var_return <- aggregate(RET.USD ~ ym, data = sd_help, FUN = var)

dummy <- sd_help %>%
  group_by(ym) %>%
  summarize(mean(RET.USD),median(RET.USD),NROW(Id),sd(RET.USD),var(RET.USD))
  colnames(dummy) <- c("ym","Mean","Median","n","sd","var")

df1 <- inner_join(sd_help,dummy,by="ym")

# sample variance
df1$potOfRetMinμ <- ((df1$RET.USD - df1$Mean)^2)

df2 <- df1 %>%
  group_by(ym) %>%
  summarize(sum(potOfRetMinμ))

df3 <- inner_join(dummy,df2,by="ym")

colnames(df3) <- c("ym","Mean","Median","n","sd","var","SumPotOfRetMinμ")

df3$var_OtherCalc <- (1/(df3$n-1))*(df3$SumPotOfRetMinμ)
df3$sd_OtherCalc <- sqrt(df3$var_OtherCalc)

df4 <- inner_join(sd_help,df3,by = "ym")
df4$Covariance <- (1/(df4$n-1))*(df4$SumPotOfRetMinμ)

plot(mean_return$ym,mean_return$RET.USD)

# yearly basis

```



```{r}
# sorting the stocks by market cap and extracting the ISINs of the biggest ones that make up 90% of a country's market cap

# RUSSIA
# 90% of the market cap in Russia: 
0.9*country_mcap$mc_sum[4]

# subsetting all Russian stocks
russian_stocks <- as.data.frame(mcap_country) %>%
   filter(country.x == "RUS") 

# sorting the dataframe of russian stocks by decreasing market cap
russian_stocks <- russian_stocks[order(russian_stocks$WC07210,decreasing = TRUE),]
 
# filtering out the big stocks which sum up to 90% of the market cap of Russian stocks
big_stocks_RUS <- russian_stocks[cumsum(russian_stocks$WC07210) <= 0.9*country_mcap$mc_sum[4],]

big_stocks_RUS



```


idea:

big_stocks <- mcap_country %>%
  select(ISIN) %>%
 sort(mcap_country$WC07210, decreasing=T)  %>%
  filter(mcap_country$WC07210 <= 0.9*country_mcap$mc_sum)

big_stocks

```{r}
# sorting the stocks by market cap and extracting the ISINs of the biggest ones that make up 90% of a country's market cap

# RUSSIA
# 90% of the market cap in Russia: 
0.9*country_mcap$mc_sum[4]

# subsetting all Russian stocks
russian_stocks <- as.data.frame(mcap_country) %>%
   filter(country.x == "RUS") 

# sorting the dataframe of russian stocks by decreasing market cap
russian_stocks <- russian_stocks[order(russian_stocks$WC07210,decreasing = TRUE),]
 
# filtering out the big stocks which sum up to 90% of the market cap of Russian stocks
big_stocks_RUS <- russian_stocks[cumsum(russian_stocks$WC07210) <= 0.9*country_mcap$mc_sum[4],]

big_stocks_RUS



  
```


# Calculating the size portfolios




