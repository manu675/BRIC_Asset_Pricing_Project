---
title: "BRIC_project"
author: 
  name: Manuel Schreiber
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
    df_print: paged
  html_notebook: default
  latex_engine: pdflatex
  pdf_document: default
  header-includes:
   - \usepackage{amsmath}
   - \usepackage{amsfonts}
---

**BRIC Project**
```{r}
# clear workspace
##rm(list=ls())
```
getting the current WD

```{r}
getwd()
```

# 0.1 Loading Libraries

```{r}
# loading libraries
library(data.table) # extension of the data.frame package. It is widely used for fast aggregation of large datasets, low latency add/update/remove of columns, quicker ordered joins, and a fast file reader.
library(dplyr) # data manipulation package
library(lubridate)
library(zoo) # methods for totally ordered indexed observations. It aims at performing calculations containing irregular time series of numeric vectors, matrices & factors
library(stats)
library(utils)
library(tidyverse)
library(readr)
library(ggplot2)
library(reshape2)
library(reshape)
library(xts)
```
# 0.2 Loading in the R.data

Data column descriptions (Worldscope):
https://www.professors.wi.tum.de/fileadmin/w00bca/fm/Worldscope_Data_Definition_Guide_Issue_15.pdf

https://docs.google.com/spreadsheets/d/1YtuJiv60Q6nKIaFJLQY60sGQErbsl_8nvPdUHmvO8vM/edit?usp=sharing

## 0.2.1 Loading data Johannes
```{r}
memory.limit(9999999999)
# loading R.data BRIC monthly
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_monthly.RData")

# loading R.data BRIC static
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_static.RData")

# loading R.data BRIC yearly
load("C:/Users/johan/Documents/BRIC_Asset_Pricing_Project/BRIC_yearly.RData")

```
## 0.2.2 Loading data Manuel
```{r}
# loading R.data BRIC monthly
load("/Users/Manu/Desktop/TUM_Master_Mgt_Technology/TUM_SS_21/Empirical Asset Pricing seminar/Seminar Thesis/BRIC_data/BRIC_monthly.RData")
# loading R.data BRIC monthly
load("/Users/Manu/Desktop/TUM_Master_Mgt_Technology/TUM_SS_21/Empirical Asset Pricing seminar/Seminar Thesis/BRIC_data/BRIC_static.RData")
# loading R.data BRIC monthly
load("/Users/Manu/Desktop/TUM_Master_Mgt_Technology/TUM_SS_21/Empirical Asset Pricing seminar/Seminar Thesis/BRIC_data/BRIC_yearly.RData")
```

## 0.2.3 Loading data Vinit
```{r}
# loading R.data BRIC monthly
load("/Users/vinitkumar/Desktop/SS2021/Cases in Finance/BRIC_Asset_Pricing_Project/BRIC_Data/BRIC_monthly.RData")

# loading R.data BRIC monthly
load("/Users/vinitkumar/Desktop/SS2021/Cases in Finance/BRIC_Asset_Pricing_Project/BRIC_Data/BRIC_static.RData")

# loading R.data BRIC monthly
load("/Users/vinitkumar/Desktop/SS2021/Cases in Finance/BRIC_Asset_Pricing_Project/BRIC_Data/BRIC_yearly.RData")
```
## 0.2.4 Loading data Chandra
```{r}
# loading R.data BRIC monthly
load("/Users/cg/Desktop/TUM/SS21/Empirical Asset Pricing Seminar/Presentation/BRIC_Data/BRIC_monthly.RData")

# loading R.data BRIC yearly
load("/Users/cg/Desktop/TUM/SS21/Empirical Asset Pricing Seminar/Presentation/BRIC_Data/BRIC_yearly.RData")

# loading R.data BRIC static
load("/Users/cg/Desktop/TUM/SS21/Empirical Asset Pricing Seminar/Presentation/BRIC_Data/BRIC_static.RData")
```


# Data preparation

## 1 Save raw data and adjust date range

```{r}
#0 save raw data
BRIC.monthly.raw <- BRIC.monthly
BRIC.yearly.raw <- BRIC.yearly

#1 adjust date range (from May 1994 to October 2018)
#1.1 leave raw data with date adjustment
BRIC.monthly.withNA <- subset(BRIC.monthly.raw, Date >= "1994-05-31")
BRIC.yearly.withNA <- subset(BRIC.yearly.raw, YEAR >= "1994" & YEAR <= "2018")
#1.2 working dataframe
BRIC.monthly <- subset(BRIC.monthly, Date >= "1994-05-31")
BRIC.yearly <- subset(BRIC.yearly, YEAR >= "1994" & YEAR <= "2018")
```


## 2 BRIC.monthly data preparation
at this point of time the data sheet is still balanced, therefore we can use the shift function
```{r}
# add a new column for the lagged MV.USD (this is the MV.USD from the previous month) 
BRIC.monthly[, LMV.USD := lag((MV.USD),1), by =Id]
# lag MV for December
BRIC.monthly[, lagMV := lag((MV),12), by =Id]

# add a new column for volatility
BRIC.monthly[, volatility := lag(rollapplyr(RET.USD, 36, sd, fill = NA, partial = 12),1), by =Id]

# Momentum
# add 12 new columns for last 12 months returns
BRIC.monthly[, lag1 := lag((RET.USD),1), by =Id]
BRIC.monthly[, lag2 := lag((RET.USD),2), by =Id]
BRIC.monthly[, lag3 := lag((RET.USD),3), by =Id]
BRIC.monthly[, lag4 := lag((RET.USD),4), by =Id]
BRIC.monthly[, lag5 := lag((RET.USD),5), by =Id]
BRIC.monthly[, lag6 := lag((RET.USD),6), by =Id]
BRIC.monthly[, lag7 := lag((RET.USD),7), by =Id]
BRIC.monthly[, lag8 := lag((RET.USD),8), by =Id]
BRIC.monthly[, lag9 := lag((RET.USD),9), by =Id]
BRIC.monthly[, lag10 := lag((RET.USD),10), by =Id]
BRIC.monthly[, lag11 := lag((RET.USD),11), by =Id]
BRIC.monthly[, lag12 := lag((RET.USD),12), by =Id]

# negative values are replaced to 0
BRIC.monthly$lag1 <- replace(BRIC.monthly$lag1,BRIC.monthly$lag1<=0,0)
BRIC.monthly$lag2 <- replace(BRIC.monthly$lag2,BRIC.monthly$lag2<=0,0)
BRIC.monthly$lag3 <- replace(BRIC.monthly$lag3,BRIC.monthly$lag3<=0,0)
BRIC.monthly$lag4 <- replace(BRIC.monthly$lag4,BRIC.monthly$lag4<=0,0)
BRIC.monthly$lag5 <- replace(BRIC.monthly$lag5,BRIC.monthly$lag5<=0,0)
BRIC.monthly$lag6 <- replace(BRIC.monthly$lag6,BRIC.monthly$lag6<=0,0)
BRIC.monthly$lag7 <- replace(BRIC.monthly$lag7,BRIC.monthly$lag7<=0,0)
BRIC.monthly$lag8 <- replace(BRIC.monthly$lag8,BRIC.monthly$lag8<=0,0)
BRIC.monthly$lag9 <- replace(BRIC.monthly$lag9,BRIC.monthly$lag9<=0,0)
BRIC.monthly$lag10 <- replace(BRIC.monthly$lag10,BRIC.monthly$lag10<=0,0)
BRIC.monthly$lag11 <- replace(BRIC.monthly$lag11,BRIC.monthly$lag11<=0,0)
BRIC.monthly$lag12 <- replace(BRIC.monthly$lag12,BRIC.monthly$lag12<=0,0)

# replacing NA's with 0
BRIC.monthly$lag1 <- replace(BRIC.monthly$lag1,is.na(BRIC.monthly$lag1),0)
BRIC.monthly$lag2 <- replace(BRIC.monthly$lag2,is.na(BRIC.monthly$lag2),0)
BRIC.monthly$lag3 <- replace(BRIC.monthly$lag3,is.na(BRIC.monthly$lag3),0)
BRIC.monthly$lag4 <- replace(BRIC.monthly$lag4,is.na(BRIC.monthly$lag4),0)
BRIC.monthly$lag5 <- replace(BRIC.monthly$lag5,is.na(BRIC.monthly$lag5),0)
BRIC.monthly$lag6 <- replace(BRIC.monthly$lag6,is.na(BRIC.monthly$lag6),0)
BRIC.monthly$lag7 <- replace(BRIC.monthly$lag7,is.na(BRIC.monthly$lag7),0)
BRIC.monthly$lag8 <- replace(BRIC.monthly$lag8,is.na(BRIC.monthly$lag8),0)
BRIC.monthly$lag9 <- replace(BRIC.monthly$lag9,is.na(BRIC.monthly$lag9),0)
BRIC.monthly$lag10 <- replace(BRIC.monthly$lag10,is.na(BRIC.monthly$lag10),0)
BRIC.monthly$lag11 <- replace(BRIC.monthly$lag11,is.na(BRIC.monthly$lag11),0)
BRIC.monthly$lag12 <- replace(BRIC.monthly$lag12,is.na(BRIC.monthly$lag12),0)

# positive values are replaced to 1
BRIC.monthly$lag1 <- replace(BRIC.monthly$lag1,BRIC.monthly$lag1>0,1)
BRIC.monthly$lag2 <- replace(BRIC.monthly$lag2,BRIC.monthly$lag2>0,1)
BRIC.monthly$lag3 <- replace(BRIC.monthly$lag3,BRIC.monthly$lag3>0,1)
BRIC.monthly$lag4 <- replace(BRIC.monthly$lag4,BRIC.monthly$lag4>0,1)
BRIC.monthly$lag5 <- replace(BRIC.monthly$lag5,BRIC.monthly$lag5>0,1)
BRIC.monthly$lag6 <- replace(BRIC.monthly$lag6,BRIC.monthly$lag6>0,1)
BRIC.monthly$lag7 <- replace(BRIC.monthly$lag7,BRIC.monthly$lag7>0,1)
BRIC.monthly$lag8 <- replace(BRIC.monthly$lag8,BRIC.monthly$lag8>0,1)
BRIC.monthly$lag9 <- replace(BRIC.monthly$lag9,BRIC.monthly$lag9>0,1)
BRIC.monthly$lag10 <- replace(BRIC.monthly$lag10,BRIC.monthly$lag10>0,1)
BRIC.monthly$lag11 <- replace(BRIC.monthly$lag11,BRIC.monthly$lag11>0,1)
BRIC.monthly$lag12 <- replace(BRIC.monthly$lag12,BRIC.monthly$lag12>0,1)

# lag1 not included!
BRIC.monthly$lagSum <- BRIC.monthly$lag2 + BRIC.monthly$lag3 + BRIC.monthly$lag4 + BRIC.monthly$lag5 + BRIC.monthly$lag6 + BRIC.monthly$lag7 + BRIC.monthly$lag8 + BRIC.monthly$lag9 + BRIC.monthly$lag10 + BRIC.monthly$lag11 + BRIC.monthly$lag12

BRIC.monthly[ , pf.momentum := ifelse(lagSum>=8,"Winner",ifelse(lagSum < 8,"Looser",NA))]

# custom momentum for robustness checks
BRIC.monthly$customlagSum <- BRIC.monthly$lag1 + BRIC.monthly$lag2 + BRIC.monthly$lag3 + BRIC.monthly$lag4 + BRIC.monthly$lag5 + BRIC.monthly$lag6 + BRIC.monthly$lag7 + BRIC.monthly$lag8 + BRIC.monthly$lag9 + BRIC.monthly$lag10 + BRIC.monthly$lag11 + BRIC.monthly$lag12

BRIC.monthly[ , pf.customMomentum := ifelse(customlagSum>=8,"Winner",ifelse(customlagSum < 8,"Looser",NA))]

# group
BRIC.monthly[,month := month(Date)]
BRIC.monthly[,year := year(Date)]
BRIC.monthly[,hcjun := ifelse(month>=7,year,year-1)]

# MV.USD.June and MV.December column
intermediate <- filter(BRIC.monthly,BRIC.monthly$month == 7)
intermediate2 <- filter(BRIC.monthly,BRIC.monthly$month == 12)

# minimise for join
intermediate <- subset(intermediate, select = c("Id","LMV.USD","hcjun"))
colnames(intermediate)[2] <- "MV.USD.June"
intermediate2 <- subset(intermediate2, select = c("Id","lagMV","hcjun"))
colnames(intermediate2)[2] <- "MV.December"
BRIC.monthly <- subset(BRIC.monthly, select = c("Id","country","Date","MV","MV.USD","LMV.USD","RET","RET.USD","volatility","pf.momentum","pf.customMomentum","ym","hcjun","year","month"))

# inner join automatically deletes values where MV.USD.June is not available
BRIC.monthly <- inner_join(x = BRIC.monthly,y = intermediate, by = c("Id","hcjun"))
BRIC.monthly <- inner_join(x = BRIC.monthly,y = intermediate2, by = c("Id","hcjun"))
# order BRIC.monthly
BRIC.monthly <- subset(BRIC.monthly, select = c("Id","country","Date","MV","MV.USD","LMV.USD","MV.USD.June","MV.December","RET","RET.USD","volatility","pf.momentum","pf.customMomentum","ym","hcjun","year","month"))

# scaling
BRIC.monthly$MV <- BRIC.monthly$MV * 1000000
BRIC.monthly$MV.USD <- BRIC.monthly$MV.USD * 1000000
BRIC.monthly$LMV.USD <- BRIC.monthly$LMV.USD * 1000000
BRIC.monthly$MV.USD.June <- BRIC.monthly$MV.USD.June * 1000000
BRIC.monthly$MV.December <- BRIC.monthly$MV.December * 1000000
BRIC.monthly$MVChangeRate <- BRIC.monthly$MV.December/BRIC.monthly$MV

# 1/4 rebalancing information
BRIC.monthly[, leadr1 := lead((RET.USD),1), by =Id]
BRIC.monthly[, leadr2 := lead((RET.USD),2), by =Id]
BRIC.monthly[, leadm1 := lead((LMV.USD),1), by =Id]
BRIC.monthly[, leadm2 := lead((LMV.USD),2), by =Id]

# limit time period
BRIC.monthly <- subset(BRIC.monthly, Date >= "1994-06-30" & Date <= "2018-10-31")

```

## 2.1 Raw code to remove NAs (BRIC.monthly)

```{r}
# delete na's, set 0 and calculate important values
# no RET.USD data, no MV or no LMV.USD
BRIC.monthly <- BRIC.monthly %>%
  drop_na(RET.USD,MV,MV.USD,LMV.USD,MV.USD.June,MV.December,volatility,pf.momentum)
```



## 3 BRIC.yearly data preparation and value calculation

```{r}
#3.0 the BRIC.yearly panel here is still balanced! We need to add a column for total assets the year before ----
#add the lagged WC02999 (shifted by Id) (this is the WC02999 from the previous year) 
BRIC.yearly[, lag.value:=c(0, WC02999[-.N]), by=Id] 
# rename column to TotalAssetsBefore
colnames(BRIC.yearly)[106] <- "TotalAssetsBefore"

#3.1 book value / equity and related ----
# delete rows with no WC03501 (Common equity)
BRIC.yearly <- BRIC.yearly %>%
  drop_na(WC03501)
# set WC03263 (deferred taxes) zero if NA
BRIC.yearly$WC03263 <- BRIC.yearly$WC03263 %>% replace_na(0)
# add column for BookEquity (Hanauer 2020 calculation)
BRIC.yearly$BookEquity <- BRIC.yearly$WC03501 + BRIC.yearly$WC03263
# delete rows with negative BookEquity
BRIC.yearly <- BRIC.yearly[BRIC.yearly$BookEquity >= 0,]

#3.2 total assets ----
# delete rows with no WC02999 (total assets)
BRIC.yearly <- BRIC.yearly %>%
  drop_na(WC02999)
# delete rows with no TotalAssetsBefore
BRIC.yearly <- BRIC.yearly %>%
  drop_na(TotalAssetsBefore)

#3.3 operating profits ----
# "To have a valid value, at least one of cost components cost of goods sold, selling, general and administrative expenses, or interest expense must be non-missing." (Hanauer, 2019, p. 284) --> if one of these values is missing, we must delete these rows WC01001,WC01051,WC01101,WC01251
# delete rows where ALL 4 columns are NA
BRIC.yearly <- filter(BRIC.yearly,!is.na(WC01001) | !is.na(WC01051) | !is.na(WC01101) | !is.na(WC01251))
# replace all na's in this 4 columns with 0
BRIC.yearly$WC01001 <- BRIC.yearly$WC01001 %>% replace_na(0)
BRIC.yearly$WC01051 <- BRIC.yearly$WC01051 %>% replace_na(0)
BRIC.yearly$WC01101 <- BRIC.yearly$WC01101 %>% replace_na(0)
BRIC.yearly$WC01251 <- BRIC.yearly$WC01251 %>% replace_na(0)
# calculate operating profits (Hanauer, 2019, p.284)
BRIC.yearly$OperatingProfits <- (BRIC.yearly$WC01001 - BRIC.yearly$WC01051 - BRIC.yearly$WC01101 - BRIC.yearly$WC01251)

# 3.4 minimise data frame ----
# for BRIC.yearly we keep: Id, country, ICBSUC, YEAR, BookEquity, OperatingProfits and total assets
# Note: WC07201 is not used, as our MV should be the MV from the monthly data for 06.y !
BRIC.yearly <- subset(BRIC.yearly, select = c("Id","country","ICBSUC","YEAR","BookEquity","OperatingProfits","WC02999","TotalAssetsBefore"))
# we rename WC02999 to total assets
colnames(BRIC.yearly)[7] <- "TotalAssets"

# 3.5 create a help column hcdec (1 year lag) ----
BRIC.yearly$hcdec <- BRIC.yearly$YEAR + 1

# scaling
BRIC.yearly$BookEquity <- BRIC.yearly$BookEquity*1000
BRIC.yearly$OperatingProfits <- BRIC.yearly$OperatingProfits*1000
BRIC.yearly$TotalAssets <- BRIC.yearly$TotalAssets*1000
BRIC.yearly$TotalAssetsBefore <- BRIC.yearly$TotalAssetsBefore *1000
```


# 4 FF5FM Calculation
## 4.1 Adding the 1-m treasury rate to the monthly data
```{r}
# load data sheet from French's website
FFData <- read_csv("FF_Research_Data_5_Factors_2x3.CSV", 
     skip = 2)
# shorting data frame
one_m_tbill <- as.data.frame(FFData[c("X1","RF")][1:693,])
# adding a ym column to risk free rate data
one_m_tbill$ym<-as.yearmon(one_m_tbill$X1, "%Y %m")
#delete X1 column 
one_m_tbill <- subset(one_m_tbill,select = c("X1","ym","RF"))
# merge risk-free rate (1 month treasury bill rate) with monthly data
BRIC.monthly <- left_join(x = BRIC.monthly, y = one_m_tbill, by = "ym")

# make rf column numeric
BRIC.monthly$RF <- as.numeric(BRIC.monthly$RF)

# Add RiRF ----
BRIC.monthly$RiRF <- BRIC.monthly$RET.USD - BRIC.monthly$RF
# Local currency RiRF
BRIC.monthly$RiRF.local <- BRIC.monthly$RET - BRIC.monthly$RF

```
## 4.2 Merge monthly and accounting (yearly) data
NOTE: Here we "loose" around 600 000 rows! 

```{r}
BRIC.maindata <- inner_join(x = BRIC.monthly,y = BRIC.yearly, by = c("Id","hcjun" = "hcdec"))

# Add a B/M column
BRIC.maindata$BM_Devil <- BRIC.maindata$BookEquity / BRIC.maindata$MV
# Add a OP/BE column
BRIC.maindata$OPBE <- BRIC.maindata$OperatingProfits / BRIC.maindata$BookEquity
# Add a AssetGrowth column
BRIC.maindata$AssetGrowth <- ((BRIC.maindata$TotalAssets - BRIC.maindata$TotalAssetsBefore)/BRIC.maindata$TotalAssetsBefore)

# we only look at data after July 1996
BRIC.maindata <- subset(BRIC.maindata, hcjun >= "1996")

BRIC.maindata$BM <- BRIC.maindata$BookEquity / BRIC.maindata$MV.December

#summary(BRIC.maindata)
```

## BREAKPOINT
If we want to calculate factors or anything else for countries standalone we will have to filter them here!
For multiple trys run 4.2 again, to reset BRIC.maindata
```{r}
# e.g. filter for China
#BRIC.maindata <- filter(BRIC.maindata,BRIC.maindata$country.x == "CHN")
```

## 4.3 SMB: Determine size Breakpoints
```{r}
setorder(BRIC.maindata,Date,-MV.USD.June)
hlpvariable <-  BRIC.maindata[month==7 & !is.na(MV.USD.June),
                .(pf.size = ifelse((cumsum(MV.USD.June)/sum(MV.USD.June))>=0.97,"Micro",ifelse((cumsum(MV.USD.June)/sum(MV.USD.June))>=0.90,"Small","Big")),Id),
                               by=year]

# Merge the size portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable,
                       by.x=c("hcjun","Id"),
                       by.y=c("year","Id"),
                       all.x=T)

# delete NA's (only about 1000 rows)
BRIC.maindata <- na.omit(BRIC.maindata,cols = "pf.size")

# delete micro stocks
BRIC.maindata <- filter(BRIC.maindata,BRIC.maindata$pf.size != "Micro")

#aggregate(MV.USD ~ pf.size,BRIC.maindata,FUN=sum)
#sum(BRIC.maindata$MV.USD)
```

RiRF used for benchmark in p.50 lecture slides
For annualisation we used arithmetic average * 12

## 4.4 - 4.5 Benchmark and Market

```{r}
# 4.4 Benchmark (Value weighted) ----
# create copy
BRIC.benchmark <- BRIC.maindata

# filter on pf.size
BRIC.benchmark <- subset(BRIC.benchmark, pf.size == "Big" )

# value weight returns
## calculate monthly market value over all stocks
BRIC.benchmark.valueWeights <- aggregate(LMV.USD ~ ym, data = BRIC.benchmark, FUN = sum)
colnames(BRIC.benchmark.valueWeights)[2] <- "TotalValue"

## join value weights to stocks
BRIC.benchmark <- inner_join(x = BRIC.benchmark, y = BRIC.benchmark.valueWeights, by = "ym")

## calculate value weight
BRIC.benchmark$ValueWeight <- BRIC.benchmark$LMV.USD/BRIC.benchmark$TotalValue

## calculate value weight excess return / return
BRIC.benchmark$wRet <- BRIC.benchmark$ValueWeight*BRIC.benchmark$RET.USD
BRIC.benchmark$wExRet <- BRIC.benchmark$ValueWeight * BRIC.benchmark$RiRF

# per month
benchmark.retBricM <- aggregate(cbind(wRet,wExRet) ~ ym + hcjun, data = BRIC.benchmark,FUN = sum)

# per year
benchmark.retBricY <- aggregate(cbind(wRet,wExRet) ~ hcjun, data = benchmark.retBricM,FUN = mean)

## annualise
benchmark.retBricY$wRet <- benchmark.retBricY$wRet*12
benchmark.retBricY$wExRet <- benchmark.retBricY$wExRet*12

# per country
benchmark.retCountryM <- aggregate(cbind(wRet,wExRet) ~ country.x + ym + hcjun, data = BRIC.benchmark,FUN = sum)

# per year
benchmark.retCountryY <- aggregate(cbind(wRet,wExRet) ~ country.x + hcjun, data = benchmark.retCountryM,FUN = mean)

## annualise
benchmark.retCountryY$wRet <- benchmark.retCountryY$wRet*12
benchmark.retCountryY$wExRet <- benchmark.retCountryY$wExRet*12

# single dataframe
benchmark_BRIC <- inner_join(benchmark.retBricY,benchmark.retBricM,by = "hcjun")
benchmark_Country <- inner_join(benchmark.retCountryY,benchmark.retCountryM,by = c("hcjun","country.x"))
# rename columns
colnames(benchmark_BRIC)[2] <- "YearlyReturn"
colnames(benchmark_BRIC)[3] <- "YearlyExcessReturn"
colnames(benchmark_BRIC)[5] <- "MonthlyReturn"
colnames(benchmark_BRIC)[6] <- "MonthlyExcessReturn"

colnames(benchmark_Country)[3] <- "YearlyReturn"
colnames(benchmark_Country)[4] <- "YearlyExcessReturn"
colnames(benchmark_Country)[6] <- "MonthlyReturn"
colnames(benchmark_Country)[7] <- "MonthlyExcessReturn"

# 4.5 Market (Excess) Return ----

# create copy
BRIC.market <- BRIC.maindata

# value weight returns
## calculate monthly market value over all stocks
BRIC.market.valueWeights <- aggregate(LMV.USD ~ ym, data = BRIC.market, FUN = sum)
colnames(BRIC.market.valueWeights)[2] <- "TotalValue"

## join value weights to stocks
BRIC.market <- inner_join(x = BRIC.market, y = BRIC.market.valueWeights, by = "ym")

## calculate value weight
BRIC.market$ValueWeight <- BRIC.market$LMV.USD/BRIC.market$TotalValue

## calculate value weight excess return / return
BRIC.market$wRet <- BRIC.market$ValueWeight*BRIC.market$RET.USD
BRIC.market$wExRet <- BRIC.market$ValueWeight * BRIC.market$RiRF

# per month
market.retBricM <- aggregate(cbind(wRet,wExRet) ~ ym + hcjun, data = BRIC.market,FUN = sum)

# per year
market.retBricY <- aggregate(cbind(wRet,wExRet) ~ hcjun, data = market.retBricM,FUN = mean)

## annualise
market.retBricY$wRet <- market.retBricY$wRet*12
market.retBricY$wExRet <- market.retBricY$wExRet*12

# per country
market.retCountryM <- aggregate(cbind(wRet,wExRet) ~ country.x + ym + hcjun, data = BRIC.market,FUN = sum)

# per year
market.retCountryY <- aggregate(cbind(wRet,wExRet) ~ country.x + hcjun, data = market.retCountryM,FUN = mean)

## annualise
market.retCountryY$wRet <- market.retCountryY$wRet*12
market.retCountryY$wExRet <- market.retCountryY$wExRet*12

# single dataframe
market_BRIC <- inner_join(market.retBricY,market.retBricM,by = "hcjun")
market_Country <- inner_join(market.retCountryY,market.retCountryM,by = c("hcjun","country.x"))
# rename columns
colnames(market_BRIC)[2] <- "YearlyReturn"
colnames(market_BRIC)[3] <- "YearlyExcessReturn"
colnames(market_BRIC)[5] <- "MonthlyReturn"
colnames(market_BRIC)[6] <- "MonthlyExcessReturn"

colnames(market_Country)[3] <- "YearlyReturn"
colnames(market_Country)[4] <- "YearlyExcessReturn"
colnames(market_Country)[6] <- "MonthlyReturn"
colnames(market_Country)[7] <- "MonthlyExcessReturn"
```
## 4.6 - 4.8 Determine other breakpoints
```{r}

# 4.6.1 HML: Determine B/M breakpoints ----

# Determine the B/M breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(BM) & pf.size=="Big", .(bm_bb30 = quantile(BM , probs = c(0.3), na.rm=T),
                                                                        bm_bb70 = quantile(BM , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the B/M portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.maindata[ , pf.bm := ifelse(BM>bm_bb70,"High",ifelse((BM<=bm_bb70 & BM>bm_bb30),"Neutral",ifelse(BM<=bm_bb30,"Low",NA)))]

BRIC.maindata[, SIZE_VALUE := paste0(pf.size,".",pf.bm)]

# 4.6.2 HML_Devil: ----

# Determine the B/M_Devil breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(BM_Devil) & pf.size=="Big", .(bmdevil_bb30 = quantile(BM_Devil , probs = c(0.3), na.rm=T),
                                                                        bmdevil_bb70 = quantile(BM_Devil , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the B/M_Devil portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.maindata[ , pf.bmdevil := ifelse(BM_Devil>bmdevil_bb70,"High",ifelse((BM_Devil<=bmdevil_bb70 & BM_Devil>bmdevil_bb30),"Neutral",ifelse(BM_Devil<=bmdevil_bb30,"Low",NA)))]

BRIC.maindata[, SIZE_VALUE_D := paste0(pf.size,".",pf.bmdevil)]

# 4.7 RMW: Determine OP/BE breakpoints ----

# Determine the OP/BE breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(OPBE) & pf.size=="Big", .(opbe_bb30 = quantile(OPBE , probs = c(0.3), na.rm=T),
                                                                        opbe_bb70 = quantile(OPBE , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the OP/BE portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

# 3 OP/BE brackets: Robust, Neutral and Weak
BRIC.maindata[ , pf.opbe := ifelse(OPBE>opbe_bb70,"Robust",ifelse((OPBE<=opbe_bb70 & OPBE>opbe_bb30),"Neutral",ifelse(OPBE<=opbe_bb30,"Weak",NA)))]

BRIC.maindata[, SIZE_PROFITABILITY := paste0(pf.size,".",pf.opbe)]

# 4.8 CMA: Determine Asset Change Breakpoints ----

#investment: As in Cooper et al. (2008), we measure asset growth in June of year y as the percentage change in total assets (WC02999) from fiscal year ending in calendar year y−2 to fiscal year ending in calendar year y−1.

# Determine the AC breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(AssetGrowth) & pf.size=="Big", .(ac_bb30 = quantile(AssetGrowth , probs = c(0.3), na.rm=T),
                                                                        ac_bb70 = quantile(AssetGrowth , probs = c(0.7), na.rm=T)),by=year]
              
# Merge the AC portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

# 3 investment brackets: Aggressive, neutral and conservative
BRIC.maindata[ , pf.ac := ifelse(AssetGrowth>ac_bb70,"Aggressive",ifelse((AssetGrowth<=ac_bb70 & AssetGrowth>ac_bb30),"Neutral",ifelse(AssetGrowth<=ac_bb30,"Conservative",NA)))]

BRIC.maindata[, SIZE_INVESTMENT := paste0(pf.size,".",pf.ac)]
```
##4.9 Calculate Factors
```{r}
# HML ----
portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
  group_by(ym,SIZE_VALUE) %>% # do "everything" for the groups specified here
  summarize(ret.port = weighted.mean(RET.USD,
                                     LMV.USD)) %>% # vw returns using lagged mcap
  spread(SIZE_VALUE,ret.port) %>% # create one column for each group
  mutate(
    Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
    Big = (Big.High + Big.Neutral + Big.Low)/3,
    SMB_HML = Small-Big,
    High = (Small.High + Big.High)/2,
    Low = (Small.Low + Big.Low)/2,
    HML = High-Low
  )

portfolio_hml <- as.data.table(portfolio_hml)

# HML_Devil ----
portfolio_hmldevil <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bmdevil)] %>% # this operator nests functions
  group_by(ym,SIZE_VALUE_D) %>% # do "everything" for the groups specified here
  summarize(ret.port = weighted.mean(RET.USD,
                                     LMV.USD)) %>% # vw returns using lagged mcap
  spread(SIZE_VALUE_D,ret.port) %>% # create one column for each group
  mutate(
    Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
    Big = (Big.High + Big.Neutral + Big.Low)/3,
    SMB_HML_DEVIL = Small-Big,
    High = (Small.High + Big.High)/2,
    Low = (Small.Low + Big.Low)/2,
    HML_DEVIL = High-Low
  )

portfolio_hmldevil <- as.data.table(portfolio_hmldevil)

# RMW ----
portfolio_rmw <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.opbe)] %>% # this operator nests functions
  group_by(ym,SIZE_PROFITABILITY) %>% # do "everything" for the groups specified here
  summarize(ret.port = weighted.mean(RET.USD,
                                     LMV.USD)) %>% # vw returns using lagged mcap
  spread(SIZE_PROFITABILITY,ret.port) %>% # create one column for each group
  mutate(
    Small = (Small.Robust + Small.Neutral + Small.Weak)/3, # just exemplary
    Big = (Big.Robust + Big.Neutral + Big.Weak)/3,
    SMB_RMW = Small-Big,
    Robust = (Small.Robust + Big.Robust)/2,
    Weak = (Small.Weak + Big.Weak)/2,
    RMW = Robust - Weak
  )

portfolio_rmw <- as.data.table(portfolio_rmw)

# CMA ----
portfolio_cma <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.ac)] %>% # this operator nests functions
  group_by(ym,SIZE_INVESTMENT) %>% # do "everything" for the groups specified here
  summarize(ret.port = weighted.mean(RET.USD,
                                     LMV.USD)) %>% # vw returns using lagged mcap
  spread(SIZE_INVESTMENT,ret.port) %>% # create one column for each group
  mutate(
    Small = (Small.Aggressive + Small.Neutral + Small.Conservative)/3, # just exemplary
    Big = (Big.Aggressive + Big.Neutral + Big.Conservative)/3,
    SMB_CMA = Small-Big,
    Aggressive = (Small.Aggressive + Big.Aggressive)/2,
    Conservative = (Small.Conservative + Big.Conservative)/2,
    CMA = Conservative - Aggressive
  )

portfolio_cma <- as.data.table(portfolio_cma)

# MOM ----
portfolio_mom <- BRIC.maindata[!is.na(pf.momentum)] %>% 
  group_by(ym,pf.momentum) %>% 
  summarize(ret.port = weighted.mean(RET.USD,
                                     LMV.USD)) %>% 
  spread(pf.momentum,ret.port) %>% 
  mutate(
    MOM = Winner - Looser
  )
portfolio_mom <- as.data.table(portfolio_mom)

factors <- inner_join(x = portfolio_hml, y = portfolio_rmw, by = "ym")
factors <- inner_join(x = factors, y = portfolio_cma, by = "ym")
factors <- inner_join(x = factors, y = portfolio_mom, by = "ym")
factors <- inner_join(x = factors, y = portfolio_hmldevil, by = "ym")
factors <- inner_join(x = factors, y = market.retBricM, by = "ym")
colnames(factors)[55] <- "RMRF"
factors <- subset(factors, select = c("ym","RMRF","CMA","HML","HML_DEVIL","RMW","SMB_HML","SMB_RMW","SMB_CMA","MOM"))
factors$SMB <- ((factors$SMB_HML + factors$SMB_RMW + factors$SMB_CMA)/3)
factors <- subset(factors, select = c("ym","RMRF","SMB","HML","HML_DEVIL","RMW","CMA","MOM"))

#summary(factors)
#summary(BRIC.maindata$BM)
```
# 5 Strategy Sorting

Momentum sorting is done during #2.
```{r}
BRIC.strategy <- BRIC.maindata

# 5.1 Value Breakpoints ----

# subsetting the large cap stocks only (rebalanced yearly)
BRIC.strategy <- subset(BRIC.strategy, pf.size == "Big" )

# 5.1.1 B/M Devil ----
helper <- BRIC.strategy[month==7, .(median_devil = quantile(BM_Devil , probs = c(0.5), na.rm=T)),by=year]
BRIC.strategy <- merge(BRIC.strategy,helper,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)
BRIC.strategy[ , pf.growth := ifelse(BM_Devil>median_devil,"Value",(ifelse(BM_Devil<=median_devil,"Growth",NA)))]

# 5.1.2 normal B/M ----

helper <- BRIC.strategy[month==7, .(median_normal = quantile(BM, probs = c(0.5), na.rm=T)),by=year]
BRIC.strategy <- merge(BRIC.strategy,helper,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)
BRIC.strategy[ , pf.value := ifelse(BM>median_normal,"Value",(ifelse(BM<=median_normal,"Growth",NA)))]

# 5.2 Low Vol ----
helper <- BRIC.strategy[month==7, .(lower_20 = quantile(volatility , probs = c(0.2), na.rm=T)),by=year]
BRIC.strategy <- merge(BRIC.strategy,helper,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)
BRIC.strategy[ , pf.low_vol := ifelse(volatility>lower_20,"HighVol",(ifelse(volatility<=lower_20,"LowVol",NA)))]

# 5.3 Filtering ----

# filtering for growth or value stocks PLEASE COMMENT OUT and DECOMMENT OUT respectively
#BRIC.strategy <- subset(BRIC.strategy, pf.value == "Value" )
BRIC.strategy <- subset(BRIC.strategy, pf.growth == "Growth" )

# filtering for lowVol stocks
BRIC.strategy <- subset(BRIC.strategy, pf.low_vol == "LowVol" )

# filtering for winner stocks
BRIC.strategy <- subset(BRIC.strategy, pf.momentum  == "Winner" )
# custom momentum
#BRIC.strategy <- subset(BRIC.strategy, pf.customMomentum == "Winner" )

# assign new variable
strategy <- BRIC.strategy

```
## 5.4 1/4ly rebalancing
```{r}
# We can use the %in% operator to filter data by a logical vector
# setting up a df with the right months for quarterly rebalancing
quarterly <- subset(BRIC.strategy,month==c(1,4,7,10))
quarterly <- BRIC.strategy
quarterly$ym_1 <- quarterly$ym + 1/12
quarterly$ym_2 <- quarterly$ym + 2/12
qu1 <- subset(quarterly,select = c("ym","RET.USD","LMV.USD","Id","country.x","hcjun"))
qu2 <- subset(quarterly,select = c("ym_1","leadr1","leadm1","Id","country.x","hcjun"))
qu3 <- subset(quarterly,select = c("ym_2","leadr2","leadm2","Id","country.x","hcjun"))
colnames(qu2)[1] <- "ym"
colnames(qu2)[2] <- "RET.USD"
colnames(qu2)[3] <- "LMV.USD"
colnames(qu3)[1] <- "ym"
colnames(qu3)[2] <- "RET.USD"
colnames(qu3)[3] <- "LMV.USD"

qfull <- rbind(qu1,qu2,qu3)
risk_f <- subset(one_m_tbill,X1 >= 199606 & X1 <= 201810)
qfull <- left_join(x = qfull,y = risk_f,by = "ym")
qfull$RiRF <- qfull$RET.USD - as.double(qfull$RF)

strategy <- qfull
```

# 6 Portfolio Statistics
```{r}
## when using equal weights don't run until BREAK

# 6.1 Value weights ----

# value weight returns
# calculate monthly market value over all stocks
strategy.valueWeights <- aggregate(LMV.USD ~ ym, data = strategy, FUN = sum)
colnames(strategy.valueWeights)[2] <- "TotalValue"

# join value weights to stocks
strategy <- inner_join(x = strategy, y = strategy.valueWeights, by = "ym")

# calculate value weight
strategy$Weight <- strategy$LMV.USD/strategy$TotalValue

# calculate value weight excess return / return
strategy$wRet <- strategy$Weight*strategy$RET.USD
strategy$wExRet <- strategy$Weight * strategy$RiRF

## TOP 10 ----
strategy_topTen <- strategy %>% arrange(desc(Weight)) %>% group_by(ym) %>% top_n(wt=Weight,10)
strategy.topTenBricY <- aggregate(Weight ~ ym, data = strategy_topTen, FUN = sum)
strategy.topTenBricT <- mean(strategy.topTenBricY$Weight)

## BREAK ... run from here when using equal weights

# 6.2 Strategy Statistics ----

## RETURNS ----

# per month
strategy.retBricM_intermediate <- aggregate(cbind(wRet,wExRet) ~ ym + hcjun, data = strategy,FUN = sum)

# add risk-free rate if there's no investment in a month
# risk_free rate for investment horizon
risk_free <- subset(one_m_tbill,X1 >= 199606 & X1 <= 201810)
# add hcjun
risk_free$year <- as.numeric(format(risk_free$ym, "%Y"))
risk_free$month <- as.numeric(format(risk_free$ym, "%m"))
risk_free <- data.table(risk_free)
risk_free[,hcjun := ifelse(month>=7,year,year-1)]

# left join risk_free rate and retBricM_intermediate
strategy.retBricM <- left_join(x = risk_free, y = strategy.retBricM_intermediate, by = "ym")
# exchange wExRet with 0 if na and wRet with RF if na
strategy.retBricM$wExRet <- strategy.retBricM$wExRet %>% replace_na(0)
strategy.retBricM[,wRetNew := ifelse(!is.na(wRet),wRet,RF)]
strategy.retBricM$wRet <- as.double(strategy.retBricM$wRetNew)
# rename
colnames(strategy.retBricM)[6] <- "hcjun"

strategy.retBricM <- subset(strategy.retBricM, select = c("ym","hcjun","wRet","wExRet"))

# per year
strategy.retBricY <- aggregate(cbind(wRet,wExRet) ~ hcjun, data = strategy.retBricM,FUN = mean)
# annualisation
strategy.retBricY$wRet <- strategy.retBricY$wRet * 12
strategy.retBricY$wExRet <- strategy.retBricY$wExRet * 12
# mean return of whole period
strategy.retBricT <- mean(strategy.retBricY$wRet) 

# mean excess return of whole period
strategy.retExBricT <- mean(strategy.retBricY$wExRet) 

## STANDARD DEVIATION ----

# we calculate the sd out of the annualised portfolio returns
strategy.sdBricT <- sd(strategy.retBricY$wRet) 

## SHARP RATIO ----

strategy.srBricT <- strategy.retExBricT/strategy.sdBricT 

## MAX DRAWDOWN ----

drawdown <- function(ret) {
   cum.ret  <- c(0, cumsum(ret))
   drawdown <- cum.ret - cummax(cum.ret)
   return(tail(drawdown, -1))
}

maxdrawdown <- function(ret)min(drawdown(ret))
ret <- strategy.retBricY$wRet
strategy.mdBricT <- maxdrawdown(ret) 

## TRACKING ERROR ----

# merge portfolio returns and benchmark returns
strategy_benchmark <- inner_join(x = strategy.retBricY, y = benchmark.retBricY, by = "hcjun")
colnames(strategy_benchmark)[2] <- "wRet_strategy"
colnames(strategy_benchmark)[3] <- "wExRet_strategy"
colnames(strategy_benchmark)[4] <- "wRet_benchmark"
colnames(strategy_benchmark)[5] <- "wExRet_benchmark"
strategy_benchmark$pf_activeReturn <- strategy_benchmark$wRet_strategy - strategy_benchmark$wRet_benchmark
strategy.teBricT <- sd(strategy_benchmark$pf_activeReturn) 

## INFROMATION RATIO ----

strategy.irBricT <- mean(strategy_benchmark$pf_activeReturn)/strategy.teBricT 

## EFFECTIVE N ----
effectiveN <- subset(strategy,select = c("ym","Id","Weight"))
effectiveN$WeightSquare <- effectiveN$Weight * effectiveN$Weight
strategy.effectiveNM <- aggregate(WeightSquare ~ ym,data = effectiveN, FUN = sum)
strategy.effectiveNM$effN <- 1/strategy.effectiveNM$WeightSquare
strategy.effectiveNT <- mean(strategy.effectiveNM$effN)

## TURNOVER ----
#filtering out unnecessary columns
turnover_calc_strategy <-subset(strategy,select= c("Id","ym","Weight","RET.USD"))
turnover_calc_strategy$RET.USD <- turnover_calc_strategy$RET.USD*(1/100)
# lagging Weight to get xi,t-1
s_weights_strategy<- subset(turnover_calc_strategy,select= c("Id","ym","Weight"))
s_weights_strategy<-reshape(s_weights_strategy, idvar = "ym", timevar = "Id", direction = "wide")
s_weights_strategy[is.na(s_weights_strategy)]=0
s_weights_strategy<-as.data.frame(s_weights_strategy)
s_lag_weights_strategy <-s_weights_strategy%>% mutate_at(vars(-"ym"),lag)
x.prevweight_strategy<-reshape(s_lag_weights_strategy, 
        direction = "long",idvar = "ym")
colnames(x.prevweight_strategy)[3]<-"WeightPrevPeriod"
#lagging RET.USD to get ri,t-1
s_returns_strategy<-subset(turnover_calc_strategy,select=c("Id","ym","RET.USD"))
#filtering for stocks in Strategy frame
s_returns_strategy<-setDT(s_returns_strategy)[Id %chin% turnover_calc_strategy$Id]
s_returns_strategy <-reshape(s_returns_strategy, idvar = "ym", timevar = "Id", direction = "wide")
s_returns_strategy [is.na(s_returns_strategy)]=0
s_returns_strategy <-as.data.frame(s_returns_strategy)
s_lag_returns_strategy <-s_returns_strategy %>% mutate_at(vars(-"ym"),lag)
x.prevret_strategy<-reshape(s_lag_returns_strategy, direction = "long",idvar = "ym")
colnames(x.prevret_strategy)[3]<-"RET.USDPrevPeriod"
x.prevret_strategy$RET.USDPrevPeriod <- x.prevret_strategy$RET.USDPrevPeriod*(1/100)
#leftjoining RET.USDPrevPeriod & WeightPrevPeriod to turnover_calc_strategy (aka strategy frame)
turnover_calc_strategy<-left_join(turnover_calc_strategy,x.prevweight_strategy,by = c("Id","ym"))
turnover_calc_strategy<-left_join(turnover_calc_strategy,x.prevret_strategy,by = c("Id","ym"))
turnover_calc_strategy [is.na(turnover_calc_strategy)]=0
#calculating x epsilon thing
#numerator
turnover_calc_strategy$x_epsilon_numerator_strategy <- turnover_calc_strategy$WeightPrevPeriod * (1+turnover_calc_strategy$RET.USDPrevPeriod)
x_epsilon_denominator_strategy <-aggregate(x_epsilon_numerator_strategy~ym,data = turnover_calc_strategy,FUN = sum)
colnames(x_epsilon_denominator_strategy)[2]<-"x_epsilon_denominator_strategy"
turnover_calc_strategy <-left_join(turnover_calc_strategy,x_epsilon_denominator_strategy,by="ym")
turnover_calc_strategy$x_epsilon_strategy <- turnover_calc_strategy$x_epsilon_numerator_strategy / turnover_calc_strategy$x_epsilon_denominator_strategy
turnover_calc_strategy [is.na(turnover_calc_strategy)]=0
turnover_calc_strategy$turnover = (turnover_calc_strategy$Weight - turnover_calc_strategy$x_epsilon_strategy) 
turnover_calc_strategy$turnover <- abs(turnover_calc_strategy$turnover)
turnover_pattern_strategy <- aggregate(turnover~ym,data = turnover_calc_strategy,FUN = sum)
turnover_pattern_strategy$turnover<- 0.5*turnover_pattern_strategy$turnover
summary(turnover_pattern_strategy$turnover)
strategy.turnover<- mean(turnover_pattern_strategy$turnover)
#plot(x=turnover_pattern_strategy$ym,y=turnover_pattern_strategy$turnover)

## AVG. NUMBER OF STOCKS ----
strat.EqualWeights <- aggregate(Id ~ ym, data = BRIC.strategy, FUN=function(x) length(unique(x)))
colnames(strat.EqualWeights)[2] <- "NumberOfStocks"
# average number of stocks
strategy.avgNumberOfStocks <- sum(strat.EqualWeights$NumberOfStocks)/length(strat.EqualWeights$NumberOfStocks)

```
## dont't run // connect again
```{r}
# 6.3 Benchmark statistics ----

# mean return of whole period
benchmark.retBricT <- mean(benchmark.retBricY$wRet) 

# mean excess return of whole period
benchmark.retExBricT <- mean(benchmark.retBricY$wExRet)

## STANDARD DEVIATION ----

# we calculate the sd out of the annualised portfolio returns
benchmark.sdBricT <- sd(benchmark.retBricY$wRet) 

## SHARP RATIO ----

benchmark.srBricT <- benchmark.retExBricT/benchmark.sdBricT 

## MAX DRAWDOWN ----

drawdown <- function(ret) {
   cum.ret  <- c(0, cumsum(ret))
   drawdown <- cum.ret - cummax(cum.ret)
   return(tail(drawdown, -1))
}

maxdrawdown <- function(ret)min(drawdown(ret))
ret <- benchmark.retBricY$wRet
benchmark.mdBricT <- maxdrawdown(ret) 

## TRACKING ERROR ----

# merge portfolio returns and benchmark returns
benchmark_benchmark <- inner_join(x = benchmark.retBricY, y = benchmark.retBricY, by = "hcjun")
colnames(benchmark_benchmark)[2] <- "wRet_benchmark"
colnames(benchmark_benchmark)[3] <- "wExRet_benchmark"
colnames(benchmark_benchmark)[4] <- "wRet_benchmark"
colnames(benchmark_benchmark)[5] <- "wExRet_benchmark"
benchmark_benchmark$pf_activeReturn <- benchmark_benchmark$wRet_benchmark - benchmark_benchmark$wRet_benchmark
benchmark.teBricT <- sd(benchmark_benchmark$pf_activeReturn)

## INFROMATION RATIO ----

benchmark.irBricT <- mean(benchmark_benchmark$pf_activeReturn)/benchmark.teBricT

## TOP 10 ----
benchmark_topTen <- BRIC.benchmark %>% arrange(desc(ValueWeight)) %>% group_by(ym) %>% top_n(wt=ValueWeight,10)
benchmark.topTenBricY <- aggregate(ValueWeight ~ ym, data = benchmark_topTen, FUN = sum)
benchmark.topTenBricT <- mean(benchmark.topTenBricY$ValueWeight)

## EFFECTIVE N ----
effectiveNBe <- subset(BRIC.benchmark,select = c("ym","Id","ValueWeight"))
effectiveNBe$WeightSquare <- effectiveNBe$ValueWeight * effectiveNBe$ValueWeight
benchmark.effectiveNM <- aggregate(WeightSquare ~ ym,data = effectiveNBe, FUN = sum)
benchmark.effectiveNM$effN <- 1/benchmark.effectiveNM$WeightSquare
benchmark.effectiveNT <- mean(benchmark.effectiveNM$effN)

## TURNOVER ----
#filtering out unnecessary columns
turnover_calc_benchmark <-subset(BRIC.benchmark,select= c("Id","ym","ValueWeight","RET.USD"))
turnover_calc_benchmark$RET.USD <- turnover_calc_benchmark$RET.USD*(1/100)
# lagging Weight to get xi,t-1
s_weights_benchmark<- subset(turnover_calc_benchmark,select= c("Id","ym","ValueWeight"))
s_weights_benchmark<-reshape(s_weights_benchmark, idvar = "ym", timevar = "Id", direction = "wide")
s_weights_benchmark[is.na(s_weights_benchmark)]=0
s_weights_benchmark<-as.data.frame(s_weights_benchmark)
s_lag_weights_benchmark <-s_weights_benchmark%>% mutate_at(vars(-"ym"),lag)
x.prevweight_benchmark<-reshape(s_lag_weights_benchmark, 
        direction = "long",idvar = "ym")
colnames(x.prevweight_benchmark)[3]<-"WeightPrevPeriod"
#lagging RET.USD to get ri,t-1
s_returns_benchmark<-subset(turnover_calc_benchmark,select=c("Id","ym","RET.USD"))
#filtering for stocks in benchmark frame
s_returns_benchmark<-setDT(s_returns_benchmark)[Id %chin% turnover_calc_benchmark$Id]
s_returns_benchmark <-reshape(s_returns_benchmark, idvar = "ym", timevar = "Id", direction = "wide")
s_returns_benchmark [is.na(s_returns_benchmark)]=0
s_returns_benchmark <-as.data.frame(s_returns_benchmark)
s_lag_returns_benchmark <-s_returns_benchmark %>% mutate_at(vars(-"ym"),lag)
x.prevret_benchmark<-reshape(s_lag_returns_benchmark, direction = "long",idvar = "ym")
colnames(x.prevret_benchmark)[3]<-"RET.USDPrevPeriod"
x.prevret_benchmark$RET.USDPrevPeriod <- x.prevret_benchmark$RET.USDPrevPeriod*(1/100)
#leftjoining RET.USDPrevPeriod & WeightPrevPeriod to turnover_calc_benchmark (aka benchmark frame)
turnover_calc_benchmark<-left_join(turnover_calc_benchmark,x.prevweight_benchmark,by = c("Id","ym"))
turnover_calc_benchmark<-left_join(turnover_calc_benchmark,x.prevret_benchmark,by = c("Id","ym"))
turnover_calc_benchmark [is.na(turnover_calc_benchmark)]=0
#calculating x epsilon thin
#numerator
turnover_calc_benchmark$x_epsilon_numerator_benchmark <- turnover_calc_benchmark$WeightPrevPeriod * (1+turnover_calc_benchmark$RET.USDPrevPeriod)
x_epsilon_denominator_benchmark <-aggregate(x_epsilon_numerator_benchmark~ym,data = turnover_calc_benchmark,FUN = sum)
colnames(x_epsilon_denominator_benchmark)[2]<-"x_epsilon_denominator_benchmark"
turnover_calc_benchmark <-left_join(turnover_calc_benchmark,x_epsilon_denominator_benchmark,by="ym")
turnover_calc_benchmark$x_epsilon_benchmark <- turnover_calc_benchmark$x_epsilon_numerator_benchmark / turnover_calc_benchmark$x_epsilon_denominator_benchmark
turnover_calc_benchmark [is.na(turnover_calc_benchmark)]=0
turnover_calc_benchmark$turnover = (turnover_calc_benchmark$Weight - turnover_calc_benchmark$x_epsilon_benchmark) 
turnover_calc_benchmark$turnover <- abs(turnover_calc_benchmark$turnover)
turnover_pattern_benchmark <- aggregate(turnover~ym,data = turnover_calc_benchmark,FUN = sum)
turnover_pattern_benchmark$turnover<- 0.5*turnover_pattern_benchmark$turnover
summary(turnover_pattern_benchmark$turnover)
benchmark.turnover<- mean(turnover_pattern_benchmark$turnover)
#plot(x=turnover_pattern_benchmark$ym,y=turnover_pattern_benchmark$turnover)

## AVG. NUMBER OF STOCKS ----
bench.EqualWeights <- aggregate(Id ~ ym, data = BRIC.benchmark, FUN=function(x) length(unique(x)))
colnames(bench.EqualWeights)[2] <- "NumberOfStocks"
# average number of stocks
benchmark.avgNumberOfStocks <- sum(bench.EqualWeights$NumberOfStocks)/length(bench.EqualWeights$NumberOfStocks)


```
## 6.4 Saving Statistics into a single data frame
```{r}
MOC_GRO_VOL_BRIC_q <- c(strategy.retBricT,strategy.retExBricT,strategy.sdBricT,strategy.srBricT,strategy.mdBricT,strategy.teBricT,strategy.irBricT, strategy.avgNumberOfStocks, strategy.topTenBricT, strategy.turnover,strategy.effectiveNT)

eval_BRIC_Benchmark <- c(benchmark.retBricT,benchmark.retExBricT,benchmark.sdBricT,benchmark.srBricT,benchmark.mdBricT,benchmark.teBricT,benchmark.irBricT, benchmark.avgNumberOfStocks, benchmark.topTenBricT, benchmark.turnover,benchmark.effectiveNT)
```

```{r}
# Big datasheet for all runs
allStrategies <- rbind(eval_BRIC_Benchmark,MOM_BRIC_m,MOC_BRIC_m,VAL_BRIC_m,GRO_BRIC_m,VOL_BRIC_m,MOM_VAL_BRIC_m,MOM_GRO_BRIC_m,MOM_VOL_BRIC_m,MOC_VAL_BRIC_m,MOC_GRO_BRIC_m,MOC_VOL_BRIC_m,VAL_VOL_BRIC_m,GRO_VOL_BRIC_m,MOM_VAL_VOL_BRIC_m,MOM_GRO_VOL_BRIC_m,MOC_VAL_VOL_BRIC_m,MOC_GRO_VOL_BRIC_m,MOM_BRIC_q,MOC_BRIC_q,VAL_BRIC_q,GRO_BRIC_q,VOL_BRIC_q,MOM_VAL_BRIC_q,MOM_GRO_BRIC_q,MOM_VOL_BRIC_q,MOC_VAL_BRIC_q,MOC_GRO_BRIC_q,MOC_VOL_BRIC_q,VAL_VOL_BRIC_q,GRO_VOL_BRIC_q,MOM_VAL_VOL_BRIC_q,MOM_GRO_VOL_BRIC_q,MOC_VAL_VOL_BRIC_q,MOC_GRO_VOL_BRIC_q)
#1-month rebalancing
MOM_BRIC_m #done
MOC_BRIC_m #done
VAL_BRIC_m #done
GRO_BRIC_m #done
VOL_BRIC_m #done
MOM_VAL_BRIC_m # done
MOM_GRO_BRIC_m # done
MOM_VOL_BRIC_m #done
MOC_VAL_BRIC_m # done
MOC_GRO_BRIC_m # done
MOC_VOL_BRIC_m #done
VAL_VOL_BRIC_m # done
GRO_VOL_BRIC_m # done
MOM_VAL_VOL_BRIC_m # done
MOM_GRO_VOL_BRIC_m # done
MOC_VAL_VOL_BRIC_m # done
MOC_GRO_VOL_BRIC_m # done

# 3-month rebalancing
MOM_BRIC_q #done
MOC_BRIC_q #done
VAL_BRIC_q #done
GRO_BRIC_q #done
VOL_BRIC_q #done
MOM_VAL_BRIC_q # done
MOM_GRO_BRIC_q # done
MOM_VOL_BRIC_q #done
MOC_VAL_BRIC_q # done
MOC_GRO_BRIC_q # done
MOC_VOL_BRIC_q #done
VAL_VOL_BRIC_q # done
GRO_VOL_BRIC_q # done
MOM_VAL_VOL_BRIC_q # done
MOM_GRO_VOL_BRIC_q # done
MOC_VAL_VOL_BRIC_q # done
MOC_GRO_VOL_BRIC_q # done

allStrategies <- as.data.frame(allStrategies)
colnames(allStrategies)[1] <- "Return"
colnames(allStrategies)[2] <- "ExcessReturn"
colnames(allStrategies)[3] <- "StandardDeviation"
colnames(allStrategies)[4] <- "SharpRatio"
colnames(allStrategies)[5] <- "MaximumDrawdown"
colnames(allStrategies)[6] <- "TrackingError"
colnames(allStrategies)[7] <- "InformationRatio"
colnames(allStrategies)[8] <- "Avg.NumberOfStocks"
colnames(allStrategies)[9] <- "top10"
colnames(allStrategies)[10] <- "Turnover"
colnames(allStrategies)[11] <- "EffectiveN"

save()

```

# 7 Spanning tests (factor exposure)

```{r}
# join factors, strategy and benchmark ----
spanning_1 <- left_join(x = factors, y = strategy.retBricM, by = "ym")
spanning <- left_join(x = spanning_1, y = market.retBricM, by = "ym")
colnames(spanning)[10] <- "Strategy_RET"
colnames(spanning)[11] <- "Strategy_RiRF"
colnames(spanning)[13] <- "Market_RET"
colnames(spanning)[14] <- "Market_RiRF"

# correlation matrix between factors

head(spanning)

dim(spanning) # 280 (24 years * 12 months) x 5

## cor(spanning[,-"ym"]) # correlation matrix between factors for the BRIC region

summary(spanning) # to use for a table

# Spanning Tests ----
## FF3FM
summary(lm(data=spanning, formula = Strategy_RiRF ~ Market_RiRF + SMB + HML))

## FF5FM
summary(lm(data=spanning, formula = Strategy_RiRF ~ Market_RiRF + SMB + HML + CMA + RMW))

## FF3FM + MOM
summary(lm(data=spanning, formula = Strategy_RiRF ~ Market_RiRF + SMB + HML + MOM))

## FF5FM + MOM
summary(lm(data=spanning, formula = Strategy_RiRF ~ Market_RiRF + SMB + HML + CMA + RMW + MOM))


```
# 8 Plots and Visualisation
## 8.0 Loading data
```{r}
load("statistics/differentStrategies_all.RData")
load("statistics/differentStrategies_BRIC.RData")
load("statistics/differentStrategies_CHN.RData")
load("statistics/differentStrategies_RUS.RData")
load("statistics/differentStrategies_IND.RData")
load("statistics/differentStrategies_BRA.RData")
load("statistics/factors_BRIC.RData")
load("statistics/factors_CHN.RData")
load("statistics/factors_RUS.RData")
load("statistics/factors_IND.RData")
load("statistics/factors_BRA.RData")
```

## 8.1 Benchmark vs Strategy
```{r}
dim(benchmark.retBricM)
dim(strategy.retBricM)

# inner join 
bm_plot_df <- inner_join(x=benchmark.retBricM, y=strategy.retBricM, by="ym")

bm_plot_df

# zoo objects for cummulative performance 
benchmark.zoo <- zoo(bm_plot_df$wRet.x) # zoo object

# cummulative performance of 1 EUR
bm_plot_df$bm.cum_ret <- cumsum(log(1+benchmark.zoo/100)) # cum log returns

strategy.zoo <- zoo(bm_plot_df$wRet.y)

bm_plot_df$strat.cum_ret = cumsum(log(1+strategy.zoo/100))



# creating a dataframe for plotting the cummulative returns
df_new <- data.frame(bm.cret = as.vector(bm_plot_df$bm.cum_ret),
                     strat.cret = as.vector(bm_plot_df$strat.cum_ret),
                     time = bm_plot_df$ym)

# saving the plot as a jpeg file
jpeg("strategy_vs_bm_plot.jpeg", width = 480, height = 480) # height and width can be chosen as your wish 

# strategy returns vs big stocks benchmark 
strategy_vs_bm_returns <- ggplot(data = bm_plot_df, aes(x = ym)) + 
  geom_line(aes(y = bm.cum_ret, colour="bm.cum_ret")) + 
  geom_line(aes(y = strat.cum_ret, colour="strat.cum_ret")) + 
  labs(y= "Cum. Log Returns", x = "Year", title ="Monthly Cum. Log Returns: 3FStrategy : [insert strategy] vs Benchmark") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Portfolio", 
                      breaks = c("bm.cum_ret", "strat.cum_ret"),
                      labels= c("Benchmark","3FStrategy"), # legend label names
                      values = c("red", "green"))
  
strategy_vs_bm_returns

# second part of the code that creates the jpeg file of the plot
dev.off()
```
## 8.2 Evolution of MarketCap Weights

```{r}
# 8.2.1 STRATEGY ----

# create a balanced panel
ym <- seq(as.yearmon('1996-07-01'), as.yearmon('2018-10-31'), by = 0.083333333333333333333333333)
ym <- as.data.frame(ym)
country.x <- c("BRA","CHN","IND","RUS")
country.x <- as.data.frame(country.x)

# preparing data sheet
ymCountries <- crossing(ym,country.x)
evolution.valueWeights <- aggregate(LMV.USD ~ ym + country.x, data = strategy, FUN = sum)
balanced_strategy <- left_join(x = ymCountries, y = evolution.valueWeights, by = c("ym", "country.x"))
evolution <- left_join(x = balanced_strategy, y = strategy.valueWeights, by = "ym")
evolution$LMV.USD <- evolution$LMV.USD %>% replace_na(0)
evolution$TotalValue <- evolution$TotalValue %>% replace_na(0)
evolution$CountryShare <- evolution$LMV.USD/evolution$TotalValue
evolution_w <- inner_join(x = evolution, y = evolution, by = "ym")
evolution_u <- inner_join(x = evolution, y = evolution_w, by = "ym")
evolution_v <- inner_join(x = evolution, y = evolution_u, by = "ym")
evolution <- filter(evolution_v,country.x.x.x == "BRA" & country.x.y == "CHN" & country.x.x == "IND" & country.x.y.y == "RUS")
colnames(evolution)[5] <- "BRA"
colnames(evolution)[9] <- "CHN"
colnames(evolution)[13] <- "IND"
colnames(evolution)[17] <- "RUS"
evolution <- subset(evolution, select = c("ym","BRA","CHN","IND","RUS"))

# saving the plot as a jpeg file
jpeg("weights_strategy.jpg", width = 480, height = 480) # height and width can be chosen as your wish

overview_strategy <- ggplot(data = evolution, aes(x = ym)) + 
  geom_line(aes(y = BRA, colour="BRA")) + 
  geom_line(aes(y = CHN, colour="CHN")) + 
  geom_line(aes(y = IND, colour="IND")) + 
  geom_line(aes(y = RUS, colour="RUS")) + 
  labs(y= "country weight", x = "ym", title ="Country Weights by Value in the 3FStrategy : [insert strategy]") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Country weight", 
                      breaks = c("BRA", "CHN", "IND", "RUS"),
                      values = c("red", "green", "blue","orange"))

# second part of the code that creates the jpeg file of the plot
dev.off()

# 8.2.2 BENCHMARK ----

# create a balanced panel
ym <- seq(as.yearmon('1996-07-01'), as.yearmon('2018-10-31'), by = 0.083333333333333333333333333)
ym <- as.data.frame(ym)
country.x <- c("BRA","CHN","IND","RUS")
country.x <- as.data.frame(country.x)

# preparing data sheet
ymCountries <- crossing(ym,country.x)
evolution.valueWeights <- aggregate(LMV.USD ~ ym + country.x, data = BRIC.benchmark, FUN = sum)
balanced_strategy <- left_join(x = ymCountries, y = evolution.valueWeights, by = c("ym", "country.x"))
evolution <- left_join(x = balanced_strategy, y = BRIC.benchmark.valueWeights, by = "ym")
evolution$LMV.USD <- evolution$LMV.USD %>% replace_na(0)
evolution$TotalValue <- evolution$TotalValue %>% replace_na(0)
evolution$CountryShare <- evolution$LMV.USD/evolution$TotalValue
evolution_w <- inner_join(x = evolution, y = evolution, by = "ym")
evolution_u <- inner_join(x = evolution, y = evolution_w, by = "ym")
evolution_v <- inner_join(x = evolution, y = evolution_u, by = "ym")
evolution <- filter(evolution_v,country.x.x.x == "BRA" & country.x.y == "CHN" & country.x.x == "IND" & country.x.y.y == "RUS")
colnames(evolution)[5] <- "BRA"
colnames(evolution)[9] <- "CHN"
colnames(evolution)[13] <- "IND"
colnames(evolution)[17] <- "RUS"
evolution <- subset(evolution, select = c("ym","BRA","CHN","IND","RUS"))

# saving the plot as a jpeg file
jpeg("weights_benchmark.jpg", width = 480, height = 480) # height and width can be chosen as your wish

overview_benchmark <- ggplot(data = evolution, aes(x = ym)) + 
  geom_line(aes(y = BRA, colour="BRA")) + 
  geom_line(aes(y = CHN, colour="CHN")) + 
  geom_line(aes(y = IND, colour="IND")) + 
  geom_line(aes(y = RUS, colour="RUS")) + 
  labs(y= "country weight", x = "ym", title ="Country Weights by Value in the Benchmark") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Country weight", 
                      breaks = c("BRA", "CHN", "IND", "RUS"),
                      values = c("red", "green", "blue","orange"))

# second part of the code that creates the jpeg file of the plot
dev.off()

overview_benchmark
overview_strategy
strategy_vs_bm_returns
```
## 8.3 Factor Returns
```{r}
# factor return plots
library(ggplot2)

cma.zoo <- zoo(factors$CMA) # zoo object

factors$cma.cum_ret = cumsum(log(1+cma.zoo/100)) # cum log returns

hml.zoo <- zoo(factors$HML)

factors$hml.cum_ret = cumsum(log(1+hml.zoo/100))

rmw.zoo <- zoo(factors$RMW)

factors$rmw.cum_ret = cumsum(log(1+rmw.zoo/100))

smb.zoo <- zoo(factors$SMB)

factors$smb.cum_ret = cumsum(log(1+smb.zoo/100))

hml_devil.zoo <- zoo(factors$HML_DEVIL)

factors$hml_devil.cum_ret = cumsum(log(1+hml_devil.zoo/100))

rmrf.zoo <- zoo(factors$RMRF)

factors$rmrf.cum_ret = cumsum(log(1+rmrf.zoo/100))



# creating a dataframe for plotting the cummulative returns
df_new <- data.frame(cma.cret = as.vector(factors$cma.cum_ret),
                     rmrf.cret = as.vector(factors$rmrf.cum_ret),
                     smb.cret = as.vector(factors$smb.cum_ret),
                     hml.cret = as.vector(factors$hml.cum_ret),
                     hml_devil.cret = as.vector(factors$hml_devil.cum_ret),
                     rmw.cret = as.vector(factors$rmw.cum_ret),
                     time = as.Date(factors$ym))

# plot of the factor returns (log scale)
cum_rets <- ggplot(data = df_new, aes(x = time))   +
   geom_line(aes(y = rmrf.cret, colour="rmrf.cret")) +
  geom_line(aes(y = smb.cret, colour="smb.cret")) + 
  geom_line(aes(y = hml.cret, colour="hml.cret")) +
  geom_line(aes(y = hml_devil.cret, colour="hml_devil.cret")) +
  geom_line(aes(y = rmw.cret, colour="rmw.cret")) + 
  geom_line(aes(y = cma.cret, colour="cma.cret")) + 
  labs(y= "cum. log return", x = "Year", title ="Monthly cum. factor log returns") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Factor", 
                      breaks = c("rmrf.cret","smb.cret", "hml.cret","hml_devil.cret", "rmw.cret", "cma.cret"),
                      values = c("black","red", "green","yellow", "blue","orange"))
  
cum_rets
 

# factor returns (regular scale)
factor_returns <- ggplot(data = factors, aes(x = ym)) + 
  geom_line(aes(y = RMRF, colour="RMRF")) +
  geom_line(aes(y = SMB, colour="SMB")) + 
  geom_line(aes(y = HML, colour="HML")) + 
  geom_line(aes(y = HML_DEVIL, colour="HML_DEVIL")) +
  geom_line(aes(y = RMW, colour="RMW")) + 
  geom_line(aes(y = CMA, colour="CMA")) + 
  labs(y= "country weight", x = "Year", title ="Monthly factor returns") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Country weight", 
                      breaks = c("RMRF","SMB", "HML","HML_DEVIL", "RMW", "CMA"),
                      values = c("black","red", "green","yellow", "blue","orange"))
  
factor_returns



```

## 8.4 Strategy Comparison (3factor, 2factor, 1factor)
```{r}

rownames(differentStrategies.BRIC) <- c("Benchmark", "3F","V", "GLV","GMOM","LVMOM","G","LV","MOM")


# transforming the index of the df into a column
factor_plot_df <- setDT(differentStrategies.BRIC, keep.rownames = TRUE)

# dropping an unnecessary row
factor_plot_df <- factor_plot_df[-3,]


# renaming the 1st column
colnames(factor_plot_df)[1] <-  "Strategies"

# saving the plot as a jpeg file
jpeg("risk_return_factors.jpeg", width = 480, height = 480) # height and width can be chosen as your wish 
# Zooming in with xlim/ylim
plot_combinations <- ggplot(data = factor_plot_df, aes(x = Volatility, y = Return, color= Strategies)) +
  geom_point(size = 3, alpha = 0.9, shape = 20) +
  geom_text(color= "black", aes(label=Strategies,label=""),show_guide=F,hjust=0.6,vjust=-0.5) +
  labs(y= "Strategy Return (in % p.a.)", x = "Volatility (SD in % p.a.)", title ="Risk-return space of factor combinations") + # x and y axis lables and plot title  
theme(plot.title = element_text(face="bold", hjust=0.5)) +
 scale_color_discrete(name = "Strategies", labels = c("3 Factor", "Benchmark", "Growth", "Growth_LowVol", "Growth_Momentum","LowVol","LowVolMomentum","Momentum"))


plot_combinations

# second part of the code that creates the jpeg file of the plot
dev.off()

```

# 9 Descriptive Statistics
```{r}
deStats <- BRIC.maindata
deStats <- subset(deStats, pf.size == "Big" )

# BRIC
tu <- aggregate(Id ~ ym, data = deStats, FUN=function(x) length(unique(x)))
fu <- aggregate(MV.USD ~ ym, data = deStats, FUN=sum)

BRIC_descriptiveStats <- rbind(length(unique(deStats$Id)),min(tu$Id),round(mean(tu$Id),digits = 2),max(tu$Id),format(mean(fu$MV.USD),scientific = TRUE),format(median(fu$MV.USD),scientific = TRUE),format(sum(deStats$MV.USD),scientific = TRUE),100,as.character(min(tu$ym)),as.character(max(tu$ym)))
colnames(BRIC_descriptiveStats)[1] <- "BRIC"
colnames(BRIC_descriptiveStats)[1] <- "BRIC"

# countrywise
wu <- aggregate(Id ~ country.x, data = deStats, FUN=function(x) length(unique(x)))
zu <- aggregate(Id ~ ym + country.x, data = deStats, FUN=function(x) length(unique(x))) # check individually
su <- aggregate(MV.USD ~ ym + country.x, data = deStats, FUN=sum)

# BRA
wu_BRA <- subset(wu,country.x == "BRA")
zu_BRA <- subset(zu,country.x == "BRA")
su_BRA <- subset(su,country.x == "BRA")

BRA <- rbind(wu_BRA$Id,min(zu_BRA$Id),round(mean(zu_BRA$Id),digits = 2),max(zu_BRA$Id),format(mean(su_BRA$MV.USD),scientific = TRUE),format(median(su_BRA$MV.USD),scientific = TRUE),format(sum(su_BRA$MV.USD),scientific = TRUE),round(as.double((sum(su_BRA$MV.USD)*100)/sum(deStats$MV.USD)),digits = 2),as.character(min(su_BRA$ym)),as.character(max(su_BRA$ym)))
colnames(BRA)[1] <- "Brazil"

# RUS
wu_RUS <- subset(wu,country.x == "RUS")
zu_RUS <- subset(zu,country.x == "RUS")
su_RUS <- subset(su,country.x == "RUS")

RUS <- rbind(wu_RUS$Id,min(zu_RUS$Id),round(mean(zu_RUS$Id),digits = 2),max(zu_RUS$Id),format(mean(su_RUS$MV.USD),scientific = TRUE),format(median(su_RUS$MV.USD),scientific = TRUE),format(sum(su_RUS$MV.USD),scientific = TRUE),round(as.double((sum(su_RUS$MV.USD)*100)/sum(deStats$MV.USD)),digits = 2),as.character(min(su_RUS$ym)),as.character(max(su_RUS$ym)))
colnames(RUS)[1] <- "Russia"

# IND
wu_IND <- subset(wu,country.x == "IND")
zu_IND <- subset(zu,country.x == "IND")
su_IND <- subset(su,country.x == "IND")

IND <- rbind(wu_IND$Id,min(zu_IND$Id),round(mean(zu_IND$Id),digits = 2),max(zu_IND$Id),format(mean(su_IND$MV.USD),scientific = TRUE),format(median(su_IND$MV.USD),scientific = TRUE),format(sum(su_IND$MV.USD),scientific = TRUE),round(as.double((sum(su_IND$MV.USD)*100)/sum(deStats$MV.USD)),digits = 2),as.character(min(su_IND$ym)),as.character(max(su_IND$ym)))
colnames(IND)[1] <- "India"

# CHN
wu_CHN <- subset(wu,country.x == "CHN")
zu_CHN <- subset(zu,country.x == "CHN")
su_CHN <- subset(su,country.x == "CHN")

CHN <- rbind(wu_CHN$Id,min(zu_CHN$Id),round(mean(zu_CHN$Id),digits = 2),max(zu_CHN$Id),format(mean(su_CHN$MV.USD),scientific = TRUE),format(median(su_CHN$MV.USD),scientific = TRUE),format(sum(su_CHN$MV.USD),scientific = TRUE),round(as.double((sum(su_CHN$MV.USD)*100)/sum(deStats$MV.USD)),digits = 2),as.character(min(su_CHN$ym)),as.character(max(su_CHN$ym)))
colnames(CHN)[1] <- "China"

# one data frame
descriptive_statistics <- cbind(BRIC_descriptiveStats,BRA,RUS,IND,CHN)
rownames(descriptive_statistics)[1:10] <- rbind("Total no. firms","Min no. firms","Mean no. firms","Max no. firms","Mean size in USD","Median size in USD","Total size in USD","% of total size","Start ym","End ym")

descriptive_statistics <- as.data.frame(descriptive_statistics)

library("writexl")
save(descriptive_statistics,file = "descriptive_statistics.RData")
write_xlsx(descriptive_statistics,"descriptive_statistics.xlsx")

```
# 6.1 (ALTERNATIVE) Equal weights 
// rarely used... don't run value weights part in 6 when running this!!
// Every stock has the same weight within a ym
```{r}
# assign a new working variable
#strategy <- BRIC.strategy

strategy.EqualWeights <- aggregate(Id ~ ym, data = strategy, FUN=function(x) length(unique(x)))
colnames(strategy.EqualWeights)[2] <- "NumberOfStocks"

## join value weights to stocks
strategy <- inner_join(x = strategy, y = strategy.EqualWeights, by = "ym")

## calculate value weight
strategy$Weight <- 1/strategy$NumberOfStocks

## calculate value weight excess return / return
strategy$wRet <- strategy$Weight*strategy$RET.USD
strategy$wExRet <- strategy$Weight * strategy$RiRF

# TOP 10 ----
strategy.EqualWeights$weight <- 1/strat.EqualWeights$NumberOfStocks
strategy.topTenBricT <- mean(strategy.EqualWeights$weight)
```

# A.1 Crazy combination
```{r}
# crazy combination trial
##5.1 Value Breakpoints

BRIC.strategy <- BRIC.maindata

colnames(BRIC.strategy)

## Value factor
## creating a large cap and high B/M ratio column (large cap value)

# subsetting the large cap stocks only (rebalanced yearly)
BRIC.strategy <- subset(BRIC.strategy, pf.size == "Big" )

# subsetting only value stocks (cutoff = median) Look up CUTOFF details
# Determine the value breakpoints
hlpvariable2 <- BRIC.strategy[month==7, .(median = quantile(BM_Devil , probs = c(0.5), na.rm=T)),by=year]
              
# Merge the value portfolio allocation back from July Y to June Y+1
BRIC.strategy <- merge(BRIC.strategy,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)
BRIC.strategy[ , pf.growth := ifelse(BM_Devil>median,"Value",(ifelse(BM_Devil<=median,"Growth",NA)))]

# Merge the value portfolio allocation back from July Y to June Y+1
hlpvariable3 <- BRIC.strategy[month==7, .(median2 = quantile(BM , probs = c(0.5), na.rm=T)),by=year]
BRIC.strategy <- merge(BRIC.strategy,hlpvariable3,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)
BRIC.strategy[ , pf.value := ifelse(BM>median2,"Value",(ifelse(BM<=median2,"Growth",NA)))]

table(BRIC.strategy$pf.value)
dim(BRIC.strategy)

---

# Determine the low_vol breakpoints based on big stocks only
hlpvariable2 <- BRIC.strategy[month==7, .(lower_20 = quantile(volatility , probs = c(0.2), na.rm=T)),by=year]
              
# Merge the low_vol portfolio allocation back from July Y to June Y+1
BRIC.strategy <- merge(BRIC.strategy,hlpvariable2,
                       by.x=c("hcjun"),
                       by.y=c("year"),
                       all.x=T)

BRIC.strategy[ , pf.low_vol := ifelse(volatility>lower_20,"HighVol",(ifelse(volatility<=lower_20,"LowVol",NA)))]

table(BRIC.strategy$pf.low_vol)
dim(BRIC.strategy)

--- 
  
# filtering for growth stocks
BRIC.strategy_1 <- subset(BRIC.strategy, pf.growth == "Growth" )
BRIC.strategy_2 <- subset(BRIC.strategy, pf.value == "Value" )
BRIC.strategy <- rbind(BRIC.strategy_1,BRIC.strategy_2)

# filtering for lowVol stocks
BRIC.strategy <- subset(BRIC.strategy, pf.low_vol == "LowVol" )

# filtering for winner stocks
BRIC.strategy <- subset(BRIC.strategy, pf.momentum  == "Winner" )

dim(BRIC.strategy)

summary(BRIC.strategy)
```
# A.2 GDP Evolution
```{r}
# load data sheet from French's website
GDPData <- read_csv("GDP_raw_data.csv", 
     skip = 3)

# rename column
colnames(GDPData)[2] <- "CountryCode"

# filter on BRIC countries
GDPData <- GDPData %>% filter(CountryCode == "IND" | CountryCode == "CHN" | CountryCode == "BRA" | CountryCode == "RUS")

# transpose data frame and keep row names
GDPData <- as.data.frame(t(GDPData))
setDT(GDPData, keep.rownames = TRUE)[]

colnames(GDPData)[1] <- "year"
colnames(GDPData)[2] <- "BRA"
colnames(GDPData)[3] <- "CHN"
colnames(GDPData)[4] <- "IND"
colnames(GDPData)[5] <- "RUS"

# shorting data frame
GDPData <- GDPData %>% filter(year >= 1994 & year < 2020 )

class(GDPData$BRA)

# convert factor type objects to numeric objects
GDPData$BRA <- as.numeric(as.character(GDPData$BRA))
GDPData$CHN <- as.numeric(as.character(GDPData$CHN))
GDPData$IND <- as.numeric(as.character(GDPData$IND))
GDPData$RUS <- as.numeric(as.character(GDPData$RUS))
GDPData$year <- as.numeric(as.character(GDPData$year))

# get the sum of all GDPs
GDPData$SumOfGDP <- GDPData$BRA + GDPData$CHN + GDPData$IND + GDPData$RUS

# get % of total GDP per country
GDPData$BRA_w <- GDPData$BRA/GDPData$SumOfGDP
GDPData$CHN_w <- GDPData$CHN/GDPData$SumOfGDP
GDPData$IND_w <- GDPData$IND/GDPData$SumOfGDP
GDPData$RUS_w <- GDPData$RUS/GDPData$SumOfGDP

# plot of GDP weights over time
overview_gdp <- ggplot(data = GDPData, aes(x = year)) + 
  geom_line(aes(y = BRA_w, colour="BRA_w")) + 
  geom_line(aes(y = CHN_w, colour="CHN_w")) + 
  geom_line(aes(y = IND_w, colour="IND_w")) + 
  geom_line(aes(y = RUS_w, colour="RUS_w")) + 
  labs(y= "country weight", x = "Year", title ="GDP weights by country") + # x and y axis lables and plot title
  theme(plot.title = element_text(face="bold", hjust=0.5)) +
  scale_colour_manual(name="Country weight", 
                      breaks = c("BRA_w", "CHN_w", "IND_w", "RUS_w"),
                      values = c("red", "green", "blue","orange"))
overview_gdp
```



```
