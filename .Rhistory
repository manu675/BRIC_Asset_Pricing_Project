#3.0 the BRIC.yearly panel here is still balanced! We need to add a column for total assets the year before ----
#add the lagged WC02999 (shifted by Id) (this is the WC02999 from the previous year)
BRIC.yearly[, lag.value:=c(0, WC02999[-.N]), by=Id]
# rename column to TotalAssetsBefore
colnames(BRIC.yearly)[106] <- "TotalAssetsBefore"
#3.1 book value / equity and related ----
# delete rows with no WC03501 (Common equity)
BRIC.yearly <- BRIC.yearly %>%
drop_na(WC03501)
# set WC03263 (deferred taxes) zero if NA
BRIC.yearly$WC03263 <- BRIC.yearly$WC03263 %>% replace_na(0)
# add column for BookEquity (Hanauer 2020 calculation)
BRIC.yearly$BookEquity <- BRIC.yearly$WC03501 + BRIC.yearly$WC03263
# delete rows with negative BookEquity
BRIC.yearly <- BRIC.yearly[BRIC.yearly$BookEquity >= 0,]
#3.2 total assets ----
# delete rows with no WC02999 (total assets)
BRIC.yearly <- BRIC.yearly %>%
drop_na(WC02999)
# delete rows with no TotalAssetsBefore
BRIC.yearly <- BRIC.yearly %>%
drop_na(TotalAssetsBefore)
#3.3 operating profits ----
# "To have a valid value, at least one of cost components cost of goods sold, selling, general and administrative expenses, or interest expense must be non-missing." (Hanauer, 2019, p. 284) --> if one of these values is missing, we must delete these rows WC01001,WC01051,WC01101,WC01251
# delete rows where ALL 4 columns are NA
BRIC.yearly <- filter(BRIC.yearly,!is.na(WC01001) | !is.na(WC01051) | !is.na(WC01101) | !is.na(WC01251))
# replace all na's in this 4 columns with 0
BRIC.yearly$WC01001 <- BRIC.yearly$WC01001 %>% replace_na(0)
BRIC.yearly$WC01051 <- BRIC.yearly$WC01051 %>% replace_na(0)
BRIC.yearly$WC01101 <- BRIC.yearly$WC01101 %>% replace_na(0)
BRIC.yearly$WC01251 <- BRIC.yearly$WC01251 %>% replace_na(0)
# calculate operating profits (Hanauer, 2019, p.284)
BRIC.yearly$OperatingProfits <- (BRIC.yearly$WC01001 - BRIC.yearly$WC01051 - BRIC.yearly$WC01101 - BRIC.yearly$WC01251)
# 3.4 minimise data frame ----
# for BRIC.yearly we keep: Id, country, ICBSUC, YEAR, BookEquity, OperatingProfits and total assets
# Note: WC07201 is not used, as our MV should be the MV from the monthly data for 06.y !
BRIC.yearly <- subset(BRIC.yearly, select = c("Id","country","ICBSUC","YEAR","BookEquity","OperatingProfits","WC02999","TotalAssetsBefore"))
# we rename WC02999 to total assets
colnames(BRIC.yearly)[7] <- "TotalAssets"
# 3.5 create a help column hcdec (1 year lag) ----
BRIC.yearly$hcdec <- BRIC.yearly$YEAR + 1
# scaling
BRIC.yearly$BookEquity <- BRIC.yearly$BookEquity*1000
BRIC.yearly$OperatingProfits <- BRIC.yearly$OperatingProfits*1000
BRIC.yearly$TotalAssets <- BRIC.yearly$TotalAssets*1000
BRIC.yearly$TotalAssetsBefore <- BRIC.yearly$TotalAssetsBefore *1000
# load data sheet from French's website
FFData <- read_csv("FF_Research_Data_5_Factors_2x3.CSV",
skip = 2)
# shorting data frame
one_m_tbill <- as.data.frame(FFData[c("X1","RF")][1:693,])
# adding a ym column to risk free rate data
one_m_tbill$ym<-as.yearmon(one_m_tbill$X1, "%Y %m")
#delete X1 column
one_m_tbill <- subset(one_m_tbill,select = c("X1","ym","RF"))
# merge risk-free rate (1 month treasury bill rate) with monthly data
BRIC.monthly <- left_join(x = BRIC.monthly, y = one_m_tbill, by = "ym")
# make rf column numeric
BRIC.monthly$RF <- as.numeric(BRIC.monthly$RF)
# Add RiRF ----
BRIC.monthly$RiRF <- BRIC.monthly$RET.USD - BRIC.monthly$RF
# Local currency RiRF
BRIC.monthly$RiRF.local <- BRIC.monthly$RET - BRIC.monthly$RF
BRIC.maindata <- inner_join(x = BRIC.monthly,y = BRIC.yearly, by = c("Id","hcjun" = "hcdec"))
# Add a B/M column
BRIC.maindata$BM_Devil <- BRIC.maindata$BookEquity / BRIC.maindata$MV
# Add a OP/BE column
BRIC.maindata$OPBE <- BRIC.maindata$OperatingProfits / BRIC.maindata$BookEquity
# Add a AssetGrowth column
BRIC.maindata$AssetGrowth <- ((BRIC.maindata$TotalAssets - BRIC.maindata$TotalAssetsBefore)/BRIC.maindata$TotalAssetsBefore)
# we only look at data after July 1996
BRIC.maindata <- subset(BRIC.maindata, hcjun >= "1996")
BRIC.maindata$BM <- BRIC.maindata$BookEquity / BRIC.maindata$MV.December
summary(BRIC.maindata)
setorder(BRIC.maindata,Date,-MV.USD.June)
hlpvariable <-  BRIC.maindata[month==7 & !is.na(MV.USD.June),
.(pf.size = ifelse((cumsum(MV.USD.June)/sum(MV.USD.June))>=0.97,"Micro",ifelse((cumsum(MV.USD.June)/sum(MV.USD.June))>=0.90,"Small","Big")),Id),
by=year]
# Merge the size portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable,
by.x=c("hcjun","Id"),
by.y=c("year","Id"),
all.x=T)
# delete NA's (only about 1000 rows)
BRIC.maindata <- na.omit(BRIC.maindata,cols = "pf.size")
# delete micro stocks
BRIC.maindata <- filter(BRIC.maindata,BRIC.maindata$pf.size != "Micro")
#aggregate(MV.USD ~ pf.size,BRIC.maindata,FUN=sum)
#sum(BRIC.maindata$MV.USD)
# create copy
BRIC.benchmark <- BRIC.maindata
# filter on pf.size
BRIC.benchmark <- subset(BRIC.benchmark, pf.size == "Big" )
# value weight returns
## calculate monthly market value over all stocks
BRIC.benchmark.valueWeights <- aggregate(LMV.USD ~ ym, data = BRIC.benchmark, FUN = sum)
colnames(BRIC.benchmark.valueWeights)[2] <- "TotalValue"
## join value weights to stocks
BRIC.benchmark <- inner_join(x = BRIC.benchmark, y = BRIC.benchmark.valueWeights, by = "ym")
## calculate value weight
BRIC.benchmark$ValueWeight <- BRIC.benchmark$LMV.USD/BRIC.benchmark$TotalValue
## calculate value weight excess return / return
BRIC.benchmark$wRet <- BRIC.benchmark$ValueWeight*BRIC.benchmark$RET.USD
BRIC.benchmark$wExRet <- BRIC.benchmark$ValueWeight * BRIC.benchmark$RiRF
# per month
benchmark.retBricM <- aggregate(cbind(wRet,wExRet) ~ ym + hcjun, data = BRIC.benchmark,FUN = sum)
# per year
benchmark.retBricY <- aggregate(cbind(wRet,wExRet) ~ hcjun, data = benchmark.retBricM,FUN = mean)
## annualise
benchmark.retBricY$wRet <- benchmark.retBricY$wRet*12
benchmark.retBricY$wExRet <- benchmark.retBricY$wExRet*12
# per country
benchmark.retCountryM <- aggregate(cbind(wRet,wExRet) ~ country.x + ym + hcjun, data = BRIC.benchmark,FUN = sum)
# per year
benchmark.retCountryY <- aggregate(cbind(wRet,wExRet) ~ country.x + hcjun, data = benchmark.retCountryM,FUN = mean)
## annualise
benchmark.retCountryY$wRet <- benchmark.retCountryY$wRet*12
benchmark.retCountryY$wExRet <- benchmark.retCountryY$wExRet*12
# single dataframe
benchmark_BRIC <- inner_join(benchmark.retBricY,benchmark.retBricM,by = "hcjun")
benchmark_Country <- inner_join(benchmark.retCountryY,benchmark.retCountryM,by = c("hcjun","country.x"))
# rename columns
colnames(benchmark_BRIC)[2] <- "YearlyReturn"
colnames(benchmark_BRIC)[3] <- "YearlyExcessReturn"
colnames(benchmark_BRIC)[5] <- "MonthlyReturn"
colnames(benchmark_BRIC)[6] <- "MonthlyExcessReturn"
colnames(benchmark_Country)[3] <- "YearlyReturn"
colnames(benchmark_Country)[4] <- "YearlyExcessReturn"
colnames(benchmark_Country)[6] <- "MonthlyReturn"
colnames(benchmark_Country)[7] <- "MonthlyExcessReturn"
# create copy
BRIC.market <- BRIC.maindata
# value weight returns
## calculate monthly market value over all stocks
BRIC.market.valueWeights <- aggregate(LMV.USD ~ ym, data = BRIC.market, FUN = sum)
colnames(BRIC.market.valueWeights)[2] <- "TotalValue"
## join value weights to stocks
BRIC.market <- inner_join(x = BRIC.market, y = BRIC.market.valueWeights, by = "ym")
## calculate value weight
BRIC.market$ValueWeight <- BRIC.market$LMV.USD/BRIC.market$TotalValue
## calculate value weight excess return / return
BRIC.market$wRet <- BRIC.market$ValueWeight*BRIC.market$RET.USD
BRIC.market$wExRet <- BRIC.market$ValueWeight * BRIC.market$RiRF
# per month
market.retBricM <- aggregate(cbind(wRet,wExRet) ~ ym + hcjun, data = BRIC.market,FUN = sum)
# per year
market.retBricY <- aggregate(cbind(wRet,wExRet) ~ hcjun, data = market.retBricM,FUN = mean)
## annualise
market.retBricY$wRet <- market.retBricY$wRet*12
market.retBricY$wExRet <- market.retBricY$wExRet*12
# per country
market.retCountryM <- aggregate(cbind(wRet,wExRet) ~ country.x + ym + hcjun, data = BRIC.market,FUN = sum)
# per year
market.retCountryY <- aggregate(cbind(wRet,wExRet) ~ country.x + hcjun, data = market.retCountryM,FUN = mean)
## annualise
market.retCountryY$wRet <- market.retCountryY$wRet*12
market.retCountryY$wExRet <- market.retCountryY$wExRet*12
# single dataframe
market_BRIC <- inner_join(market.retBricY,market.retBricM,by = "hcjun")
market_Country <- inner_join(market.retCountryY,market.retCountryM,by = c("hcjun","country.x"))
# rename columns
colnames(market_BRIC)[2] <- "YearlyReturn"
colnames(market_BRIC)[3] <- "YearlyExcessReturn"
colnames(market_BRIC)[5] <- "MonthlyReturn"
colnames(market_BRIC)[6] <- "MonthlyExcessReturn"
colnames(market_Country)[3] <- "YearlyReturn"
colnames(market_Country)[4] <- "YearlyExcessReturn"
colnames(market_Country)[6] <- "MonthlyReturn"
colnames(market_Country)[7] <- "MonthlyExcessReturn"
# 4.6.1 HML: Determine B/M breakpoints ----
# Determine the B/M breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(BM) & pf.size=="Big", .(bm_bb30 = quantile(BM , probs = c(0.3), na.rm=T),
bm_bb70 = quantile(BM , probs = c(0.7), na.rm=T)),by=year]
# Merge the B/M portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
by.x=c("hcjun"),
by.y=c("year"),
all.x=T)
BRIC.maindata[ , pf.bm := ifelse(BM>bm_bb70,"High",ifelse((BM<=bm_bb70 & BM>bm_bb30),"Neutral",ifelse(BM<=bm_bb30,"Low",NA)))]
BRIC.maindata[, SIZE_VALUE := paste0(pf.size,".",pf.bm)]
# 4.6.2 HML_Devil: ----
# Determine the B/M_Devil breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(BM_Devil) & pf.size=="Big", .(bmdevil_bb30 = quantile(BM_Devil , probs = c(0.3), na.rm=T),
bmdevil_bb70 = quantile(BM_Devil , probs = c(0.7), na.rm=T)),by=year]
# Merge the B/M_Devil portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
by.x=c("hcjun"),
by.y=c("year"),
all.x=T)
BRIC.maindata[ , pf.bmdevil := ifelse(BM_Devil>bmdevil_bb70,"High",ifelse((BM_Devil<=bmdevil_bb70 & BM_Devil>bmdevil_bb30),"Neutral",ifelse(BM_Devil<=bmdevil_bb30,"Low",NA)))]
BRIC.maindata[, SIZE_VALUE_D := paste0(pf.size,".",pf.bmdevil)]
# 4.7 RMW: Determine OP/BE breakpoints ----
# Determine the OP/BE breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(OPBE) & pf.size=="Big", .(opbe_bb30 = quantile(OPBE , probs = c(0.3), na.rm=T),
opbe_bb70 = quantile(OPBE , probs = c(0.7), na.rm=T)),by=year]
# Merge the OP/BE portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
by.x=c("hcjun"),
by.y=c("year"),
all.x=T)
# 3 OP/BE brackets: Robust, Neutral and Weak
BRIC.maindata[ , pf.opbe := ifelse(OPBE>opbe_bb70,"Robust",ifelse((OPBE<=opbe_bb70 & OPBE>opbe_bb30),"Neutral",ifelse(OPBE<=opbe_bb30,"Weak",NA)))]
BRIC.maindata[, SIZE_PROFITABILITY := paste0(pf.size,".",pf.opbe)]
# 4.8 CMA: Determine Asset Change Breakpoints ----
#investment: As in Cooper et al. (2008), we measure asset growth in June of year y as the percentage change in total assets (WC02999) from fiscal year ending in calendar year y−2 to fiscal year ending in calendar year y−1.
# Determine the AC breakpoints based on big stocks only
hlpvariable2 <- BRIC.maindata[month==7 & !is.na(AssetGrowth) & pf.size=="Big", .(ac_bb30 = quantile(AssetGrowth , probs = c(0.3), na.rm=T),
ac_bb70 = quantile(AssetGrowth , probs = c(0.7), na.rm=T)),by=year]
# Merge the AC portfolio allocation back from July Y to June Y+1
BRIC.maindata <- merge(BRIC.maindata,hlpvariable2,
by.x=c("hcjun"),
by.y=c("year"),
all.x=T)
# 3 investment brackets: Aggressive, neutral and conservative
BRIC.maindata[ , pf.ac := ifelse(AssetGrowth>ac_bb70,"Aggressive",ifelse((AssetGrowth<=ac_bb70 & AssetGrowth>ac_bb30),"Neutral",ifelse(AssetGrowth<=ac_bb30,"Conservative",NA)))]
BRIC.maindata[, SIZE_INVESTMENT := paste0(pf.size,".",pf.ac)]
# HML ----
portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
group_by(ym,SIZE_VALUE) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
spread(SIZE_VALUE,ret.port) %>% # create one column for each group
mutate(
Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
Big = (Big.High + Big.Neutral + Big.Low)/3,
SMB_HML = Small-Big,
High = (Small.High + Big.High)/2,
Low = (Small.Low + Big.Low)/2,
HML = High-Low
)
View(BRIC.maindata)
# HML ----
portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
group_by(ym,SIZE_VALUE) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
spread(SIZE_VALUE,ret.port) %>% # create one column for each group
mutate(
Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
Big = (Big.High + Big.Neutral + Big.Low)/3,
SMB_HML = Small-Big,
High = (Small.High + Big.High)/2,
Low = (Small.Low + Big.Low)/2,
HML = High-Low
)
portfolio_hmldevil <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bmdevil)] %>% # this operator nests functions
group_by(ym,SIZE_VALUE_D) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
spread(SIZE_VALUE_D,ret.port) %>% # create one column for each group
mutate(
Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
Big = (Big.High + Big.Neutral + Big.Low)/3,
SMB_HML_DEVIL = Small-Big,
High = (Small.High + Big.High)/2,
Low = (Small.Low + Big.Low)/2,
HML_DEVIL = High-Low
)
# HML ----
portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
group_by(ym,SIZE_VALUE) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
spread(SIZE_VALUE,ret.port) %>% # create one column for each group
mutate(
Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
Big = (Big.High + Big.Neutral + Big.Low)/3,
SMB_HML = Small-Big,
High = (Small.High + Big.High)/2,
Low = (Small.Low + Big.Low)/2,
HML = High-Low
)
View(BRIC.maindata)
portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
group_by(ym,SIZE_VALUE) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
View(portfolio_hml)
View(portfolio_hmldevil)
# HML ----
portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
group_by(ym,SIZE_VALUE) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
spread(SIZE_VALUE,ret.port) %>% # create one column for each group
mutate(
Small = (Small.High + Small.Neutral + Small.Low)/3, # just exemplary
Big = (Big.High + Big.Neutral + Big.Low)/3,
SMB_HML = Small-Big,
High = (Small.High + Big.High)/2,
Low = (Small.Low + Big.Low)/2,
HML = High-Low
)
portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
View(portfolio_hmldevil)
portfolio_hml <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.bm)] %>% # this operator nests functions
group_by(ym,SIZE_VALUE) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
View(portfolio_hmldevil)
View(portfolio_hmldevil)
##5.1 Value Breakpoints ----
BRIC.strategy <- BRIC.maindata
colnames(BRIC.strategy)
## Value factor
## creating a large cap and high B/M ratio column (large cap value)
# subsetting the large cap stocks only (rebalanced yearly)
BRIC.strategy <- subset(BRIC.strategy, pf.size == "Big" )
# subsetting only value stocks (cutoff = median) Look up CUTOFF details
# Determine the value breakpoints
hlpvariable2 <- BRIC.strategy[month==7, .(median = quantile(BM_Devil , probs = c(0.5), na.rm=T)),by=year]
# Merge the value portfolio allocation back from July Y to June Y+1
BRIC.strategy <- merge(BRIC.strategy,hlpvariable2,
by.x=c("hcjun"),
by.y=c("year"),
all.x=T)
BRIC.strategy[ , pf.value := ifelse(BM_Devil>median,"Value",(ifelse(BM_Devil<=median,"Growth",NA)))]
##5.2 Low Vol ----
# Determine the low_vol breakpoints based on big stocks only
hlpvariable2 <- BRIC.strategy[month==7, .(lower_20 = quantile(volatility , probs = c(0.2), na.rm=T)),by=year]
# Merge the low_vol portfolio allocation back from July Y to June Y+1
BRIC.strategy <- merge(BRIC.strategy,hlpvariable2,
by.x=c("hcjun"),
by.y=c("year"),
all.x=T)
BRIC.strategy[ , pf.low_vol := ifelse(volatility>lower_20,"HighVol",(ifelse(volatility<=lower_20,"LowVol",NA)))]
##5.3 Filtering for strategy requirements ----
# filtering for growth stocks
BRIC.strategy <- subset(BRIC.strategy, pf.value == "Growth" )
# filtering for lowVol stocks
BRIC.strategy <- subset(BRIC.strategy, pf.low_vol == "LowVol" )
# filtering for winner stocks
BRIC.strategy <- subset(BRIC.strategy, pf.momentum  == "Winner" )
View(BRIC.strategy)
View(BRIC.maindata)
View(BRIC.maindata)
View(BRIC.strategy)
# We can use the %in% operator to filter data by a logical vector
# setting up a df with the right months for quarterly rebalancing
BRIC.strategy.quarter <- subset(BRIC.strategy,month==c(1,4,7,10))
View(BRIC.strategy.quarter)
#assign a new working variable
strategy <- BRIC.strategy
# value weight returns
## calculate monthly market value over all stocks
strategy.valueWeights <- aggregate(LMV.USD ~ ym, data = strategy, FUN = sum)
colnames(strategy.valueWeights)[2] <- "TotalValue"
## join value weights to stocks
strategy <- inner_join(x = strategy, y = strategy.valueWeights, by = "ym")
## calculate value weight
strategy$Weight <- strategy$LMV.USD/strategy$TotalValue
## calculate value weight excess return / return
strategy$wRet <- strategy$Weight*strategy$RET.USD
strategy$wExRet <- strategy$Weight * strategy$RiRF
# TOP 10 ----
strategy_topTen <- strategy %>% arrange(desc(Weight)) %>% group_by(ym) %>% top_n(wt=Weight,10)
strategy.topTenBricY <- aggregate(Weight ~ ym, data = strategy_topTen, FUN = sum)
strategy.topTenBricT <- mean(strategy.topTenBricY$Weight)
# RETURNS ----
# per month
strategy.retBricM_intermediate <- aggregate(cbind(wRet,wExRet) ~ ym + hcjun, data = strategy,FUN = sum)
# add risk-free rate if there's no investment in a month
# risk_free rate for investment horizon
risk_free <- subset(one_m_tbill,X1 >= 199606 & ym <= 201810)
# add hcjun
risk_free$year <- as.numeric(format(risk_free$ym, "%Y"))
risk_free$month <- as.numeric(format(risk_free$ym, "%m"))
risk_free <- data.table(risk_free)
risk_free[,hcjun := ifelse(month>=7,year,year-1)]
# left join risk_free rate and retBricM_intermediate
strategy.retBricM <- left_join(x = risk_free, y = strategy.retBricM_intermediate, by = "ym")
# exchange wExRet with 0 if na and wRet with RF if na
strategy.retBricM$wExRet <- strategy.retBricM$wExRet %>% replace_na(0)
strategy.retBricM[,wRetNew := ifelse(!is.na(wRet),wRet,RF)]
strategy.retBricM$wRet <- as.double(strategy.retBricM$wRetNew)
# rename
colnames(strategy.retBricM)[5] <- "hcjun"
strategy.retBricM <- subset(strategy.retBricM, select = c("ym","hcjun","wRet","wExRet"))
# per year
strategy.retBricY <- aggregate(cbind(wRet,wExRet) ~ hcjun, data = strategy.retBricM,FUN = mean)
# annualisation
strategy.retBricY$wRet <- strategy.retBricY$wRet * 12
strategy.retBricY$wExRet <- strategy.retBricY$wExRet * 12
# mean return of whole period
strategy.retBricT <- mean(strategy.retBricY$wRet) # 15.329091 %
# mean excess return of whole period
strategy.retExBricT <- mean(strategy.retBricY$wExRet) # 13.111509 %
# STANDARD DEVIATION ----
# we calculate the sd out of the annualised portfolio returns
strategy.sdBricT <- sd(strategy.retBricY$wRet) # 37.155688
# SHARP RATIO ----
strategy.srBricT <- strategy.retExBricT/strategy.sdBricT # 0.352880
# MAX DRAWDOWN ----
drawdown <- function(ret) {
cum.ret  <- c(0, cumsum(ret))
drawdown <- cum.ret - cummax(cum.ret)
return(tail(drawdown, -1))
}
maxdrawdown <- function(ret)min(drawdown(ret))
ret <- strategy.retBricY$wRet
strategy.mdBricT <- maxdrawdown(ret) # -99.1467
# TRACKING ERROR ----
# merge portfolio returns and benchmark returns
strategy_benchmark <- inner_join(x = strategy.retBricY, y = benchmark.retBricY, by = "hcjun")
colnames(strategy_benchmark)[2] <- "wRet_strategy"
colnames(strategy_benchmark)[3] <- "wExRet_strategy"
colnames(strategy_benchmark)[4] <- "wRet_benchmark"
colnames(strategy_benchmark)[5] <- "wExRet_benchmark"
strategy_benchmark$pf_activeReturn <- strategy_benchmark$wRet_strategy - strategy_benchmark$wRet_benchmark
strategy.teBricT <- sd(strategy_benchmark$pf_activeReturn) # 26.831411 %
# INFROMATION RATIO ----
strategy.irBricT <- mean(strategy_benchmark$pf_activeReturn)/strategy.teBricT # 0.26754
View(strategy.retBricM)
test <- BRIC.strategy %>% # this operator nests functions
group_by(ym) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
View(test)
test <- BRIC.strategy %>% # this operator nests functions
group_by(ym) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
View(test)
View(test)
View(BRIC.strategy)
test <- BRIC.strategy %>% # this operator nests functions
group_by(ym) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
portfolio_cma <- BRIC.strategy %>%
group_by(ym) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD))
test <- BRIC.strategy %>%
group_by(ym) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD))
View(test)
test <- BRIC.strategy %>%
group_by(ym,Id) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD))
View(test)
portfolio_rmw <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.opbe)] %>% # this operator nests functions
group_by(ym,SIZE_PROFITABILITY) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
spread(SIZE_PROFITABILITY,ret.port) %>% # create one column for each group
mutate(
Small = (Small.Robust + Small.Neutral + Small.Weak)/3, # just exemplary
Big = (Big.Robust + Big.Neutral + Big.Weak)/3,
SMB_RMW = Small-Big,
Robust = (Small.Robust + Big.Robust)/2,
Weak = (Small.Weak + Big.Weak)/2,
RMW = Robust - Weak
)
portfolio_cma <- BRIC.maindata[!is.na(pf.size) & !is.na(pf.ac)] %>% # this operator nests functions
group_by(ym,SIZE_INVESTMENT) %>% # do "everything" for the groups specified here
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>% # vw returns using lagged mcap
spread(SIZE_INVESTMENT,ret.port) %>% # create one column for each group
mutate(
Small = (Small.Aggressive + Small.Neutral + Small.Conservative)/3, # just exemplary
Big = (Big.Aggressive + Big.Neutral + Big.Conservative)/3,
SMB_CMA = Small-Big,
Aggressive = (Small.Aggressive + Big.Aggressive)/2,
Conservative = (Small.Conservative + Big.Conservative)/2,
CMA = Conservative - Aggressive
)
test <- BRIC.strategy %>%
group_by(ym) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>%
spread(ym,ret.port)
test <- BRIC.strategy %>%
group_by(ym,Id) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>%
spread(Id,ret.port)
View(BRIC.strategy)
test <- BRIC.strategy %>%
group_by(ym,country.x) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>%
spread(country.x,ret.port)
test <- BRIC.strategy %>%
group_by(ym,country.x) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>%
spread(country.x,ret.port)
View(portfolio_mom)
View(portfolio_mom)
test <- BRIC.strategy %>%
group_by(ym,country.x) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>%
spread(country.x,ret.port)
portfolio_mom <- BRIC.maindata[!is.na(pf.momentum)] %>%
group_by(ym,pf.momentum) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>%
spread(pf.momentum,ret.port) %>%
mutate(
MOM = Winner - Looser
)
portfolio_mom <- BRIC.maindata[!is.na(pf.momentum)] %>%
group_by(ym,pf.momentum) %>%
summarize(ret.port = weighted.mean(RET.USD,
LMV.USD)) %>%
spread(pf.momentum,ret.port) %>%
View(portfolio_mom)
View(portfolio_mom)
